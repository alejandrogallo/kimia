#+title: Kimia
* =CL-KIMIA=
** Introduction
What should be a good input language for a program?
A case can be made to choose lisp as an input language,
and specially Common Lisp as its dialect.

The fact that =ECL= can be easily embedded in a C or C++
program makes it quite attractive for code where quantum chemical
methods are dealt with or even machine learning codes, where
the abstraction for defining networks could very well be dealt with
through powerful lisp macros.

This document represents an investigation in this direction,
and it is written as a literate program, in the hopes that
it can be embedded in the documentation of an existing program
using =CL-KIMIA= as a powerful input user interface (IUI).

** Wrapping input

In principle we want the current user to use the input language as a
purely recipee based language, like a DSL, so we will wrap the users'
input in a monadic-like interface, where the step will return the
variable ~*KIMIA-STEPS*~ where the steps of the input are stored in
order.

#+begin_src lisp :noweb-ref kimia
(defparameter *KIMIA-STEPS* '())

(defmacro wrap-input-script (&rest arg)
  `(handler-bind
       ((error #'invoke-debugger))
     (in-package :kimia)
     (progn
       (format t "~%LISP::START evaluating KIMIA script~%")
       ,@arg
       (format t "~%LISP::DONE evaluating KIMIA~%")
       kimia::*KIMIA-STEPS*)))

;(defmacro >> (&rest args)
;  `(push (mk-stepq ,@args) *KIMIA-STEPS*))
#+end_src

#+RESULTS:
: WRAP-INPUT-SCRIPT
 
** Host code generation
*** Introduction

 From a spec, we would like to be able to create autoamtically a
 =struct= that mirror the spec in order to be passed to other functions
 in c++.

 For instance, in the case of the tensor reader, we would
 like to create the following

 #+begin_src cpp :eval yes :includes '(<string> <iostream>)
struct TensorReaderSettings {
  struct In {
    enum Mode {binary, text};
    std::string *file;
    Mode *mode;
    In() {
      mode = new Mode(binary);
      file = nullptr;
    }
  } in;
  struct Out {
    std::string *tensor;
    Out() {
      tensor = new std::string("file.out");
    }
  } out;
};
auto p = TensorReaderSettings::In::Mode::text;
std::cout << p << std::endl;
TensorReaderSettings s;
std::cout << *s.out.tensor << std::endl;
 #+end_src

 #+RESULTS:
 |        1 |
 | file.out |

 together with a converter function from a =cl_object= into
 a =TensorReaderSettings=

 #+begin_src cpp :eval no
TensorReaderSettings
cl_object_to_TensorReaderSettings (cl_object *o) {
}
 #+end_src

 And for these structs we need a functions that from a common lisp
 type constructs a declaration inside the struct or somewhere else.

 First of all we have to make a choice in order to have a simpler
 more maintainable system.
 We will translate every CL type into a poiter of a related type
 in C++, which means that in principle every type can also be =NULL=,
 or =nullptr= in C++.

 There is also the problem of having variables, we should allow
 for symbols to also be passed to any CL variable, they will act as
 named pointers, so that one step can access and modify global data
 that later on other steps can retrieve or further modify.


*** List of types

 | Built-in CL type | C++ interpretation |
 |------------------+--------------------|
 | =string=         | =std::string=      |
 | =(member :a :b)= | =enum {a, b}=      |
 | =integer=        | =int=              |
 | =double-float=   | =double=           |
 | =single-float=   | =float=            |
 | =(list F N)=     | =std::array<F, N>= |
 | =(list F)=       | =std::vector<F>=   |
 | =(vector F N)=   | =std::array<F, N>= |
 | =(vector F)=     | =std::vector<F>=   |
 | =(complex F)=    | =std::complex<F>=  |

 | Kimia CL type                                                    | C++ intepretation               |
 |------------------------------------------------------------------+---------------------------------|
 | =(or symbol null)= through =(-> a)=                              | =a*=                            |
 | =(struct [name] [list of generic variables] ((:name int) ... ))= | =struct [Name] {int name; ...}= |
 | =(enum [name] :a :b ))=                                          | =enum [Name] { A, B, }=         |

- [X] vector
- [X] symbol
- [X] string
- [X] single-float
- [X] keyword
- [X] int
- [X] double-float
- [ ] list
- [ ] hashtable
- [ ] complex



*** Type definitions idea

  Some types are high-kinded, in C++ parlance this is akin to
  having template arguments.
  Some types are already defined and some others must be defined.

- define (type type-name) :: define for the first time.
  - For built-ins in c and c++ this is just empty
  - For structs and enums, if no type-name is given it should be defined in place,
    which is useful for declaring variables.
- declare-var (type type-name var-name) :: declare a variable
  - For built-ins in c and c++ this is just =<type> <var-name>=
  - For structs and enums if no type-name is given then we define the type in place
    If a =type-name= is given then the sentence should be =<type-name> <var-name>=.
- translation ::
  (this also for nameless structs/enums/unions gives the whole struct)
- caster-snippet ::
  This is a snippet of code that should convert in the host language
  a cl_object into a memory address pointing to the object in question.
- caster-name ::
  The name of the caster function

#+begin_src lisp :eval no
(defequiv :c++ (array F integer)
  :translate (lambda (type)
               (let ((field-type (cadr type))
                     (length (caddr type)))
                 (format nil "std::array<~a, ~a>"
                         (c++-translate field-type)
                         length)))
  :declare-var nil ;; default
  :define nil      ;; default
  :caster-name "cl_object_to_array"
  :caster-snippet
  "template <typename F, int N>
  ~a (cl_object o) {
     std::array<F, N> ar;
     ... somehow build ar from o
     return (size_t)new std::array<F, N>(ar);
  }")
#+end_src

*** Define c++ types
**** Naming conventions in C++

#+begin_src lisp :noweb-ref kimia.codegen :results none
(defun endl () (format nil "~%"))

(defun c++-type-name (thing)
  (remove-if (lambda (x) (string= x "-"))
             (string-capitalize
              (string-downcase thing))))

(defun c-type-name (thing)
  (concatenate
   'string
   (substitute #\_ #\-
               (string-downcase thing))
   "_t"))

(defun c++-var-name (thing)
  (nstring-downcase
   (remove-if (lambda (x) (string= x "-"))
              (string-capitalize
               (string-downcase thing)))
   :start 0
   :end 1))

(defun c-var-name (thing)
  (concatenate
   'string
   (substitute #\_ #\-
               (string-downcase thing))))
#+end_src

***** Tests                                                        :noexport:
  #+begin_src lisp :eval no :noweb-ref test-kimia
(assert (string= (c++-type-name 'tensor-reader) "TensorReader"))
(assert (string= (c++-type-name "TeNsor-ReAder") "TensorReader"))
(assert (string= (c-type-name "TeNsor-ReAder") "tensor_reader_t"))
(assert (string= (c++-var-name "TeNsor-ReAder") "tensorReader"))
(assert (string= (c-var-name "TeNsor-ReAder") "tensor_reader"))
  #+end_src

**** =defequiv= macro

and something a little bit more challenging

  #+begin_src lisp :noweb-ref kimia.codegen
(defparameter *KIMIA-TYPES* '())

(defmacro declare-var-fn-default (lang translate)
  (ecase lang
    ((:c :c++)
     `(lambda (ty vn)
        (format nil "~a ~a;"
                (funcall ,translate ty)
                (c++-var-name vn))))))

(eval-when (:compile-toplevel :load-toplevel :execute)

  (defun caster-signature-fmt (lang)
    (ecase lang
      ((:c :c++)
       "size_t ~a (const cl_object o)")))

  (defun caster-envelope-fmt (lang)
    (ecase lang
      ((:c :c++)
       (concatenate 'string
                    "~a~%"
                    (caster-signature-fmt lang)
                    "{~%~a~%}"))))

  (defun internal-type-name (type)
    (string-downcase
     (etypecase type
       (cons (format nil "~A-~A"
                     (car type)
                     (length type)))
       (symbol type))))

  (defun defequiv-var-name (lang type)
    (intern (string-upcase (format nil "~A-~A"
                                   (internal-type-name type)
                                   lang)))))

(defmacro defequiv (lang type &key
                                translate
                                (declare-var nil)
                                (define nil)
                                (satisfies nil)
                                (caster-header "")
                                caster-name
                                caster-snippet)
  (let* ((type-lang-name (defequiv-var-name lang type))
         (fun-or-scalar (lambda (thing)
                          (etypecase thing
                            (cons (eval thing))
                            (compiled-function thing)
                            ((or null string) (eval `(lambda (&optional args)
                                                       ,thing))))))
         (translate (funcall fun-or-scalar translate))
         (caster-header-f (funcall fun-or-scalar caster-header))
         (caster-name-f (funcall fun-or-scalar caster-name))
         (caster-snippet-f (funcall fun-or-scalar caster-snippet))
         (declare-var (or declare-var (eval
                                       `(declare-var-fn-default ,lang
                                                                ,translate)))))
    `(progn
       (defparameter ,type-lang-name nil)
       (setq ,type-lang-name
             '(:translate ,translate
               :declare-var ,(funcall fun-or-scalar declare-var)
               :define ,(funcall fun-or-scalar define)
               :caster-header ,caster-header-f
               :caster-name ,caster-name-f
               :caster-snippet ,(lambda (ty)
                                  (format nil
                                          (caster-envelope-fmt lang)
                                          (funcall caster-header-f ty)
                                          (funcall caster-name-f ty)
                                          (funcall caster-snippet-f ty))))))
    ))

;; TODO: generalize these funcs
(defun caster-snippet (lang ty)
  (let ((type-lang-name (defequiv-var-name lang ty)))
    (funcall (getf (eval type-lang-name) :caster-snippet) ty)))

(defun caster-name (lang ty)
  (let ((type-lang-name (defequiv-var-name lang ty)))
    (funcall (getf (eval type-lang-name) :caster-name) ty)))

(defun translate (lang ty)
  (let ((type-lang-name (defequiv-var-name lang ty)))
    (funcall (getf (eval type-lang-name) :translate) ty)))

(defun define (lang ty)
  (let ((type-lang-name (defequiv-var-name lang ty)))
    (funcall (getf (eval type-lang-name) :define) ty)))

(defun declare-var (lang ty vn)
  (let ((type-lang-name (defequiv-var-name lang ty)))
    (funcall (getf (eval type-lang-name) :declare-var) ty vn)))

(defun caster-snippet (lang ty)
  (let ((type-lang-name (defequiv-var-name lang ty)))
    (funcall (getf (eval type-lang-name) :caster-snippet) ty)))

(defun caster-signature (lang ty)
  (let ((fmt (format nil "~a;" (caster-signature-fmt lang))))
    (format nil
            fmt
            (caster-name lang ty))))
  #+end_src

  #+RESULTS:
  : CASTER-SIGNATURE


***** Tests

#+begin_src lisp :eval no :noweb-ref test-kimia

(assert-eq (defequiv-var-name :c++ '(vector F N))
           'vector-3-c++)

(assert-eq (defequiv-var-name :c '(struct name (vars) (fields)))
           'struct-4-c)

(assert-eq (defequiv-var-name :c '(struct name (vars) (fields)))
           'struct-4-c)

(assert-eq (defequiv-var-name :c++ 'integer)
           'integer-c++)

(assert-eq (defequiv-var-name :c 'integer)
           'integer-c)
#+end_src


*** Definition for simple C++ types

#+begin_src lisp :noweb-ref kimia.codegen
(defequiv :c++ integer
  :translate "int"
  :caster-name "clint"
  :caster-snippet "return (size_t)new int(ecl_to_int(o));")
(defequiv :c++ double-float
  :translate "double"
  :caster-name "cldouble"
  :caster-snippet "return (size_t)new double(ecl_to_double(o));")
(defequiv :c++ single-float
  :translate "float"
  :caster-name "clfloat"
  :caster-snippet "return (size_t)new float(ecl_to_float(o));")
(defequiv :c++ boolean
  :translate "bool"
  :caster-name "clbool"
  :caster-snippet "return (size_t)new bool(ecl_to_bool(o));")
(defequiv :c++ string :translate "std::string")
#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x2042dc0> :DECLARE-VAR
:  #<bytecompiled-function 0x2042b40> :DEFINE #<bytecompiled-function 0x2042e10>
:  :CASTER-HEADER #<bytecompiled-function 0x2042d20> :CASTER-NAME
:  #<bytecompiled-function 0x2042af0> :CASTER-SNIPPET
:  #<bytecompiled-closure #<bytecompiled-function 0x38fd730>>)


*** Vectors

This is the cpp snippet to convert a common lisp vector into
another vector
#+begin_src cpp :noweb-ref vector-cpp-snippet
~a result(ecl_to_int(cl_length(o)));
for (size_t i=0; i < result.size(); i++) {
  ~a *element = (~a*)~a(cl_aref(2, o, i));
  result[i] = *element;
}
return (size_t)new ~a(result);
#+end_src

#+RESULTS:

where then the =caster-snippet=
is simpley just
#+begin_src lisp :noweb-ref vector-cpp-caster-snippet
(lambda (ty)
  (format nil
          +c++-vector-snippet+
          (translate :c++ ty)
          (translate :c++ (cadr ty))
          (translate :c++ (cadr ty))
          (caster-name :c++ (cadr ty))
          (translate :c++ ty)
          ))
#+end_src

#+RESULTS:
: #<bytecompiled-function 0x33d5b90>


#+begin_src lisp :noweb-ref kimia.codegen :noweb no-export
(defparameter +c++-vector-snippet+
"
<<vector-cpp-snippet>>")

(defequiv :c++ (vector F)
  :translate (lambda (ty)
               (format nil "std::vector< ~a >"
                       (translate :c++ (cadr ty))))

  :caster-name (lambda (ty)
                 (format nil "vector_of__~a"
                         (caster-name :c++ (cadr ty))))

  :caster-header (lambda (ty) (caster-signature :c++ (cadr ty)))

  :caster-snippet
     <<vector-cpp-caster-snippet>>)

(defequiv :c++ (vector F N)

  :translate (lambda (ty)
               (format nil "std::array< ~a, ~a >"
                       (translate :c++ (cadr ty))
                       (caddr ty)))

  :caster-name (lambda (ty)
                 (format nil "array_of__~a_~a"
                         (caddr ty)
                         (caster-name :c++ (cadr ty))))
  :caster-snippet
     <<vector-cpp-caster-snippet>>)


#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x2042eb0> :DECLARE-VAR
:  #<bytecompiled-function 0x2748f50> :DEFINE #<bytecompiled-function 0x2748f00>
:  :CASTER-HEADER #<bytecompiled-function 0x2042d70> :CASTER-NAME
:  #<bytecompiled-function 0x20420f0> :CASTER-SNIPPET
:  #<bytecompiled-closure #<bytecompiled-function 0x38fd730>>)

*** The struct

The most central data structure to start doing complex behaviour
is the =struct= or =class=.
In common lisp, we will consider a struct as a type as being of the form

#+begin_src lisp :eval no
(struct name-of-struct-type
  (:name-of-field-1 type-of-field-1
   :name-of-field-2 type-of-field-2
   ...))
#+end_src

and the name of the struct can be a list with
generic data types:

#+begin_src lisp :eval no
(tensor-reader double-float)
#+end_src



#+begin_src lisp :noweb-ref kimia.codegen
;; generic variables
(defequiv :c++ (G N)
  :translate (lambda (ty)
               (format nil "_G~a" (cadr ty))))

(defequiv :c++ (int N)
  :translate (lambda (ty)
               (format nil "~a >>" (cadr ty))))

(defun generic-p (type)
  (etypecase type
    (cons (eq 'g (car type)))
    (t nil)))

(defun struct-spec-p (ty)
  (and (eq (car ty) 'struct)
       (typep (cadr ty) '(or cons symbol))
       (typep (caddr ty) '(or cons symbol))
       (eql (length ty) 3)))

(defun struct-identifier-p (ty)
  (and (eq (car ty) 'struct)
       (typep (cadr ty) '(or cons symbol))
       (eql (length ty) 2)))

(deftype struct-identifier ()
  '(and cons
    (satisfies struct-identifier-p)))

(deftype struct-spec ()
  '(and cons
    (satisfies struct-spec-p)))

(defun struct-spec-name (ty)
  (check-type ty (or struct-spec struct-identifier))
  (let ((name (cadr ty)))
    (typecase name
      (symbol name)
      (cons (car name)))))

(defun struct-spec-generic-vars (ty)
  (check-type ty (or struct-spec struct-identifier))
  (etypecase (cadr ty)
    (cons (cdadr ty))
    (t nil)))

(defun struct-spec-fields (ty)
  (check-type ty struct-spec)
  (caddr ty))

(defun struct-template-line (ty)
  (let ((gvars (struct-spec-generic-vars ty)))
    (if gvars
        (if (remove-if-not #'generic-p gvars)
            (format nil "template < ~{typename ~a~^, ~} >"
                    (mapcar (lambda (x) (translate :c++ x)) gvars))
            "template")
        "")))

(defun struct-spec-symbol (struct-name)
  (intern
   (format nil "~@:(~a-spec~)"
           struct-name)))

(defun rec-subst (ls what)
  (let ((pair (car ls)))
    (etypecase pair
      (null what) ;; We are done
      (cons (rec-subst (cdr ls)
                     (subst (car pair) (cdr pair) what))))))

(defun struct-unnamed-p (ty) (null (struct-spec-name ty)))

(defun translate-struct-c++ (ty)
  (let* ((ty-name (struct-spec-name ty))
         (struct-spec (if (struct-unnamed-p ty)
                          ty
                          (eval (struct-spec-symbol ty-name))))
         (name (if ty-name (c++-type-name ty-name) ""))
         (gvars (struct-spec-generic-vars ty))
         (spec-gvars (struct-spec-generic-vars struct-spec))
         (subst-list (mapcar (lambda (x y) `(,x . ,y))
                             gvars spec-gvars))
         (specialized-spec (rec-subst subst-list struct-spec))
         (fields (struct-spec-fields specialized-spec))
         (specialized-gvars (struct-spec-generic-vars specialized-spec))
         (is-generic (remove-if-not #'generic-p specialized-gvars)))
    (format nil "~&~a~&struct ~a~a;"
            (struct-template-line ty)
            (or name "")
            (cond
              ((and specialized-gvars
                    (not is-generic))
               (format nil "< ~{~a~^, ~} >"
                       (mapcar (lambda (ty) (translate :c++ ty))
                               specialized-gvars)))
              (t
               (format nil " {~%~{  ~a~%~}}"
                       (loop for kp in fields
                             collect
                             (declare-var :c++ (cadr kp) (car kp)))))))
    ))


(defun declare-var-struct-c++ (ty vn)
  (let* ((ty-name (struct-spec-name ty))
         (pre-var (etypecase ty-name
                    (null (translate-struct-c++ ty))
                    (t (c++-type-name ty-name))))
         (gvars (struct-spec-generic-vars ty)))
    (format nil "~a~a ~a;"
            pre-var
            (if gvars
                (format nil "< ~{~a~^, ~} >"
                        (mapcar (lambda (x) (translate :c++ x))
                                gvars))
                "")
            (c++-var-name vn))))

(defun define-struct-c++ (ty)
  (format nil "~a;" (translate-struct-c++ ty)))

(defmacro defgenericstruct (name spec)
  (let* ((spec `(struct ,name ,spec))
         (struct-name (struct-spec-name spec))
         (spec-gvars (struct-spec-generic-vars spec))
         (struct-spec-var (struct-spec-symbol struct-name)))
    `(progn
       (defparameter ,struct-spec-var ',spec)
       )))

(defgenericstruct
    (tensor-reader F)
    ((:name F)
     (:lens (vector F))))

(defgenericstruct
    (davidson-solver A B C D)
    ((:vectorspace A)
     (:fields (vector B))
     (:lens (vector C))
     (:dimension (vector (vector (vector D)) 5))))

(defgenericstruct
    (Mumu F)
    ((:name F)))

(defgenericstruct
    hello-world
    ((:name string)
     (:lens (struct Penis ((:lens integer))))))

(defgenericstruct
    hello-world-2
    ((:name string)
     (:struct (struct nil ((:name string))))
     (:lens (struct Penis ((:lens integer))))))

(defequiv :c++ (struct name)
  :translate (lambda (ty) (translate-struct-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-struct-c++ ty vn))
  :define (lambda (ty) (define-struct-c++ ty)))

;; unnamed structs
(defequiv :c++ (struct nil spec)
  :translate (lambda (ty) (translate-struct-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-struct-c++ ty vn))
  :define (lambda (ty) (define-struct-c++ ty)))

#+end_src

#+RESULTS:
: HELLO-WORLD-SPEC

*** The enums
    
#+begin_src lisp :noweb-ref kimia.codegen
(defun translate-enum-c++ (ty)
  (let* ((ty-name (cadr ty))
         (name (if ty-name (c++-type-name ty-name) ""))
         (fields (cddr ty)))
    (concatenate 'string
                 "enum "
                 (or name "")
                 " {"
                 (endl)
                 (eval
                  `(concatenate 'string
                                ,@(loop for kp in fields
                                        collect
                                        (format nil
                                                "  ~a,~a"
                                                kp
                                                (endl)))))
                 "}")))

(defun declare-var-enum-c++ (ty vn)
  (let* ((name (cadr ty))
         (fields (caddr ty))
         (pre-var (etypecase name
                    (null (translate-enum-c++ ty))
                    (t (string-capitalize name)))))
    (format nil "~a ~a;" pre-var (c++-var-name vn))))

(defun define-enum-c++ (ty)
  (format nil "~a;" (translate-enum-c++ ty)))

(defequiv :c++ (enum name args)
  :translate (lambda (ty) (translate-enum-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-enum-c++ ty vn))
  :define (lambda (ty) (define-enum-c++ ty)))

(defequiv :c++ (member args)
  :translate (lambda (ty)
               (translate-enum-c++ `(enum nil ,@(cdr ty))))
  :declare-var (lambda (ty vn)
                 (declare-var-enum-c++ `(enum nil ,@(cdr ty)) vn))
  :define (lambda (ty)
            (define-enum-c++ `(enum nil ,@(cdr ty)))))
#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x2042410> :DECLARE-VAR
:  #<bytecompiled-function 0x20422d0> :DEFINE #<bytecompiled-function 0x2042280>
:  :CASTER-HEADER #<bytecompiled-function 0x20423c0> :CASTER-NAME
:  #<bytecompiled-function 0x2042370> :CASTER-SNIPPET
:  #<bytecompiled-closure #<bytecompiled-function 0x38fd730>>)



*** Run steps in C++

- we only have fields of structs to allocate or not
- we allocate all of them with new and store the address in
  the database (=map<string, size_t>=)
- then pseudocode

**** Initializing data structures

The main pseudocode would look like this

   #+begin_src python :eval no
parsed-steps = vector<string, string>; (step symbol, step name)
runner-database = vector<string, size_t>; (algo name , address to runner function)

for step-settings in steps:
      step-field-symbols = []
      for field in step-field:
          is field a symbol?
              is symbol in database?
                  step-field-symbols.append(symbol)
              else
                  v = value of symbol (should have been typechecked by CL)
                  address = malloc(v)
                  database[field] = address
          else
              symbol = create a new unique symbool
              address = malloc(v)
              database[symbol] = address
      address-step-settings = malloc(step-fields-symbols)
      step-name = step-settings["name"]
      step-symbol = get-new-symbol
      database[step-symbol] = address-step-settings
      parsed-steps.append((step-symbol, step-name))

for step-pair in all-steps:
    (* this is generated from LISP *)
    kimia_run(step-pair[0], step-pair[1])
   #+end_src

and every function to turn a =cl_object= into a proper object
should look like this

#+begin_src c++ :eval no
size_t
cl_object_to_<name_of_type>
 (cl_object o, std::vector<size_t> args) {
  ...
}
#+end_src

For instance for an integer this would be the function

#+begin_src c++ :eval no
size_t
cl_object_to_int (cl_object o, std::vector<size_t> args) {
  return new int(ecl_to_fixnum(o));
}
#+end_src

#+begin_src lisp :noweb-ref kimia.codegen
(defun struct-get-fields (s)
  (car s))
#+end_src

#+RESULTS:
: STRUCT-GET-FIELDS



**** Getting runners

 #+headers: :includes '(<string> <iostream> <functional> <map> <memory> <vector>)
 #+headers: :tangle test.cxx
 #+begin_src cpp :eval yes  :main no :cmdline --pedantic -Wall
using namespace std;

using FUN_TYPE = void (*)(size_t);
using SETTING_TYPE = size_t;

map<string, FUN_TYPE> DBF;
map<string, SETTING_TYPE> DBS;

struct TensorReader {string name; int age;};
void runTensorReader(TensorReader &s) {
  cout << "RUNNING TENSOR READER" << endl;
  cout << s.name << endl;
  cout << s.age << endl;
}

struct CCSD {string amplitudes; int level;};
void runCCSD(CCSD &s) {
  cout << "RUNNING CCSD" << endl;
  cout << s.amplitudes << endl;
  cout << s.level << endl;
}

void kimia_run(string sid, string algoid) {
  const auto settings(DBS[sid]);
  const auto runner(DBF[algoid]);
  runner(settings);
}

struct A {
  double *a;
  int *b;
};

int main () {

  TensorReader tr{"input.dat", 5};
  CCSD ccsd{"Singles and doulbes", 2};
  double *a = new double(5.5657e-8);
  int *b = new int(42);

  std::vector<size_t> input;
  input.push_back((size_t)a);
  input.push_back((size_t)b);

  A *as((A*)input.data());

  std::cout << *as->a << std::endl;
  std::cout << *as->b << std::endl;

  // char* bc(reinterpret_cast<char*>(&a));
  // std::cout << input.size() << std::endl;
  // for (int i(0); i<8; i++) input.push_back(bc[i]);
  // //input.insert(input.begin(), bc, bc + sizeof(double));
  // std::cout << (input.begin() == input.end()) << std::endl;

  DBS["tensor-reader-1"] = (SETTING_TYPE)&tr;
  DBF["tensor-reader"] = (FUN_TYPE)&runTensorReader;

  DBS["ccsd-1"] = (SETTING_TYPE)&ccsd;
  DBF["ccsd"] = (FUN_TYPE)&runCCSD;

  kimia_run("tensor-reader-1", "tensor-reader");
  kimia_run("ccsd-1", "ccsd");

  return 0;
}
 #+end_src

 #+RESULTS:
 | 5.5657e-08 |        |         |
 |         42 |        |         |
 |    RUNNING | TENSOR | READER  |
 |  input.dat |        |         |
 |          5 |        |         |
 |    RUNNING | CCSD   |         |
 |    Singles | and    | doulbes |
 |          2 |        |         |
 
** The Step
*** General idea for defining steps
  To set things in perspective, we would like to define a
  =TensorReader.lisp= file alongside =TensorReader.h= and
  =TensorReader.cxx=
  with the specification of this step, it should look something like this

  #+begin_src lisp :eval no :noweb-ref defstep-tensor-reader-example
(defstep tensor-reader
  :in
  (:name :file
   :type string
   :default "input.dat"
   :required t
   :doc "The file where the tensor is located")
  (:name :mode
   :type (member :binary :text)
   :default :binary
   :required t
   :doc "The encoding and format that the tensor is written in")
  :out
  (:name :tensor
   :type string
   :default "out.tensor"
   :required t
   :doc "The file where the tensor is located"))

  #+end_src

  and every item in the =:in= or =:out= fields
  is therefore a =step-setting-spec=.

*** Setting spec
We would like to define exactly what a setting specification (setting spec)
is. As we have seen in the example for the tensor-reader, it should be

#+begin_src lisp :eval no
(:name :file
 :type (or string null)
 :default nil
 :required t
 :doc "The file where the tensor is located")
#+end_src

We define the type =step-setting-spec= to check for the existence of the
fields and also to check that the =:default= value if of type =:type=.

  #+begin_src lisp :noweb-ref kimia.types
(defparameter *setting-spec-default* nil)
(eval-when (:compile-toplevel)
  (defun step-setting-spec-p (thing)
    (let ((ty (getf thing :type))
          (default (getf thing :default))
          (doc (getf thing :doc))
          (name (getf thing :name)))
      (check-type name keyword)
      (check-type doc string)
      (setq *setting-spec-default* default)
      ;; TODO: do this without setq
      (eval `(check-type *setting-spec-default* ,ty))
      (and name
           ty
           (member :default thing)
           (member :required thing)))))

(deftype step-setting-spec ()
  '(satisfies step-setting-spec-p))
  #+end_src

  #+RESULTS:
  : STEP-SETTING-SPEC

**** Test
We can quickly check that this code makes what we think

#+begin_src lisp :noweb-ref test-kimia.types
(let (step)
  (setq step
        '(:name :mode
          :type (member :binary :text)
          :default :binary
          :required t
          :doc "The file where the tensor is located"))
  (check-type step step-setting-spec))
#+end_src

#+RESULTS:
: NIL


*** Defining steps

 A step spec has the following syntax, as we have already
 seen

 #+begin_src lisp :eval no
(defstep
  :name name-of-the-step
  :in setting-spec*
  :out setting-spec*)
 #+end_src

For ease of writing these definitions we do not wish
to have proper lists as the value of the =:in= keyword,
so we need a function parsing exactly the =:in= part
and the =:out= part from a list

 #+begin_src lisp :noweb-ref kimia.types
(eval-when (:compile-toplevel :load-toplevel)
  (defun consume-in-out (lst &optional (tail '()))
    (let ((first (car lst))
          (rest (cdr lst)))
      (cond
        ((eq first :out) `(,(reverse tail) ,rest))
        ((eq first :in) (consume-in-out rest tail))
        ((eq lst '()) `(,(reverse tail) ,rest))
        (t (consume-in-out rest (cons first tail)))))))

(defun get-keys (lst &optional (rest '()))
  "This function just gets every other element
  "
  (check-type lst (or cons null))
  (let ((head (car lst))
        (tail (cdr lst)))
    (case tail
      ((nil) (reverse rest))
      (otherwise (get-keys (cdr tail)
                           (cons head rest))))))

#+end_src

#+RESULTS:
: GET-KEYS

We still need the definition of a step.

#+begin_src lisp :noweb-ref kimia.types
(defun step-setting-typep (setting-pair setting-spec-list)
  (let* ((key (car setting-pair))
         (value (getf setting-pair key))
         (spec (car (remove-if-not (lambda (s)
                                     (eq key (getf s :name)))
                                   setting-spec-list))))
    (typep value (getf spec :type))))

(defun step-setting-step-to-struct-spec (step-name args)
  " Input is
    'Tensor-Reader (:in setting-spec* :out setting-spec*)
  "
  (let* ((inout (consume-in-out args))
         (in-struct `(struct nil ,(mapcar
                                   (lambda (kp)
                                     `(,(getf kp :name)
                                       ,(getf kp :type)))
                                   (car inout))))
         (out-struct `(struct nil ,(mapcar
                                   (lambda (kp)
                                     `(,(getf kp :name)
                                       ,(getf kp :type)))
                                   (cadr inout)))))
    `(struct ,step-name ((:in ,in-struct)
                         (:out ,out-struct)))))

(defun step-defequiv-c++ (step-name args)
  (let ((step-struct (step-setting-step-to-struct-spec step-name args)))
    (eval `(defequiv :c++ ,step-name
      :translate (lambda (ty) (translate :c++ ,step-struct))
      :declare-var (lambda (ty vn) (declare-var :c++ ,step-struct vn))
      :define (lambda (ty) (define :c++ ,step-struct))))))

(defparameter *KIMIA-TYPES* '())
(defmacro defstep (name &rest args)
  ;; checking that name and args are of correct types
  (check-type name (and symbol (not keyword)))
  (let ((inout (consume-in-out args)))
    (dolist (in-or-out inout)
      (dolist (setting in-or-out)
        (check-type setting step-setting-spec))))
  (let* ((type-predicate-name (intern (format nil "~@:(~a~)-P" name)))
         (type-name (intern (format nil "~@:(~a~)" name)))
         (spec-fun-name (intern (format nil "~@:(~a~)-SPEC" name)))
         (default-type-fn (intern (format nil "~@:(~a~)-DEFAULT" name)))
         (inout (consume-in-out args))
         (in (car inout))
         (out (cadr inout)))
    `(progn
       (step-defequiv-c++ ',name ',args)
       (defun ,default-type-fn ()
         '(:name ,name
           :in ,(reduce (lambda (x y) (concatenate 'list x y))
                 (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                  in))
           :out ,(reduce (lambda (x y) (concatenate 'list x y))
                  (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                   out))))
       (defun ,spec-fun-name ()
         '(:name ,name :in ,in :out ,out))
       (defun ,type-predicate-name (thing)
         (check-type thing cons)
         (let* ((-name (getf thing :name))
                (-in (getf thing :in))
                (-in-keys (get-keys -in))
                (-out (getf thing :out))
                (-out-keys (get-keys -out))
                (spec (,spec-fun-name))
                (spec-name (getf spec :name))
                (spec-in (getf spec :in))
                (spec-out (getf spec :out)))
           (and (eq -name spec-name)
                (every (lambda (key)
                         (let* ((value (getf -in key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-in)))
                       -in-keys)
                (every (lambda (key)
                         (let* ((value (getf -out key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-out)))
                       -out-keys))))
       (push ',type-name *KIMIA-TYPES*)
       (deftype ,type-name ()
         '(satisfies ,type-predicate-name)))))
 #+end_src

 #+RESULTS:
 : DEFSTEP

 For instance we can use this macro in the followig manner

 #+begin_src lisp :noweb yes :noweb-ref test-kimia.types :eval no
<<defstep-tensor-reader-example>>

(check-type (tensor-reader-default)
            tensor-reader)
 #+end_src

 #+RESULTS:
 : NIL

 and we can make sure that it woks for example as

 #+begin_src lisp :results none :noweb-ref test-kimia.types :eval no
(let (step default)
  (setq step
        '(:name Tensor-Reader
          :in (:file "asdf"
               :mode :binary)
          :out (:tensor "Integral")))
  (setq default
        (tensor-reader-default))

  (check-type default tensor-reader)
  (check-type step tensor-reader))
 #+end_src

A very simple macro to check the type of a step is defined below

 #+begin_src lisp :results none :noweb-ref kimia.types
(defmacro check-step-type (step)
  (let ((name (getf step :name)))
    `(let ((step ',step))
       (check-type step ,name))))
#+end_src

which we can use like
#+begin_src lisp :noweb-ref test-kimia.types :eval no
(let ((step (tensor-reader-default)))
  (eval `(check-step-type ,step)))
#+end_src

#+RESULTS:
: NIL

*** Making steps

And we just need to create a function to easier create
steps

#+begin_src lisp :results none :noweb-ref kimia.types
(defmacro mk-stepq (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (step `(:name ,name
                 :in ,in
                 :out ,out)))
    `(progn
       (check-step-type ,step)
       ',step
       )))

(defun mk-step (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (type)
         (step)
         )
    (setq type name)
    (setq step `(:name ,name
                 :in ,in
                 :out ,out))
    (eval `(check-step-type ,step))
    step))
 #+end_src

 and we can create a step in the following manner

 #+begin_src lisp :results none :noweb-ref test-kimia.types :eval no
(mk-step
 'Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")

(mk-stepq
 Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")
 #+end_src

** Testing
#+begin_src lisp :tangle src/clkimia/t.lisp :eval no :noweb no-export
(in-package :kimia)

(defmacro assert-eq (one two)
  `(let ((left-hand ,one)
         (right-hand ,two))
     (assert (eq left-hand right-hand))))

<<test-kimia>>
;; <<test-kimia.types>>

#+end_src

** The code
 #+begin_src lisp :noweb no-export :tangle src/clkimia/kimia.lisp
(defpackage :kimia
  (:use :cl)
  (:nicknames :k))
(in-package :kimia)

<<kimia.codegen>>
;;<<kimia.types>>
<<kimia>>

 #+end_src

 #+RESULTS:
 : COMMON-LISP-USER::WRAP-INPUT-SCRIPT
