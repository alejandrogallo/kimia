#+title: Kimia
* =CL-KIMIA=

What should be a good input language for a program?
A case can be made to choose lisp as an input language,
and specially Common Lisp as its dialect.

The fact that =ECL= can be easily embedded in a C or C++
program makes it quite attractive for code where quantum chemical
methods are dealt with or even machine learning codes, where
the abstraction for defining networks could very well be dealt with
through powerful lisp macros.

This document represents an investigation in this direction,
and it is written as a literate program, in the hopes that
it can be embedded in the documentation of an existing program
using =CL-KIMIA= as a powerful input user interface (IUI).

** Wrapping input

In principle we want the current user to use the input language as a
purely recipee based language, like a DSL, so we will wrap the users'
input in a monadic-like interface, where the step will return the
variable ~*KIMIA-STEPS*~ where the steps of the input are stored in
order.

#+begin_src lisp :noweb-ref kimia
(defparameter *KIMIA-STEPS* '())

(defmacro wrap-input-script (&rest arg)
  `(handler-bind
       ((error #'invoke-debugger))
       (progn
         (in-package :kimia)
         (format t "~%LISP::START evaluating KIMIA script~%")
         ,@arg
         (format t "~%LISP::DONE evaluating KIMIA~%")
         *KIMIA-STEPS*)))
#+end_src

#+RESULTS:
: WRAP-INPUT-SCRIPT
 
** The Step
*** General idea for defining steps
  To set things in perspective, we would like to define a
  =TensorReader.lisp= file alongside =TensorReader.h= and
  =TensorReader.cxx=
  with the specification of this step, it should look something like this

  #+begin_src lisp :eval no :noweb-ref defstep-tensor-reader-example
(defstep
  tensor-reader
  :in
  (:name :file
   :type (or string null)
   :default nil
   :required t
   :doc "The file where the tensor is located")
  (:name :mode
   :type (member :binary :text)
   :default :binary
   :required t
   :doc "The file where the tensor is located")
  :out
  (:name :tensor
   :type string
   :default "out.tensor"
   :required t
   :doc "The file where the tensor is located"))
  #+end_src

  and every item in the =:in= or =:out= fields
  is therefore a =step-setting-spec=.

*** Setting spec
We would like to define exactly what a setting specification (setting spec)
is. As we have seen in the example for the tensor-reader, it should be

#+begin_src lisp :eval no
(:name :file
 :type (or string null)
 :default nil
 :required t
 :doc "The file where the tensor is located")
#+end_src

We define the type =step-setting-spec= to check for the existence of the
fields and also to check that the =:default= value if of type =:type=.

  #+begin_src lisp :noweb-ref kimia.types
(defun step-setting-spec-p (thing)
  (let ((ty (getf thing :type))
        (default (getf thing :default))
        (doc (getf thing :doc))
        (name (getf thing :name)))
    (check-type name keyword)
    (check-type doc string)
    (setq *setting-spec-default* default)
    ;; TODO: do this without setq
    (eval `(check-type *setting-spec-default* ,ty))
    (and name
         ty
         (member :default thing)
         (member :required thing))))

(deftype step-setting-spec ()
  '(satisfies step-setting-spec-p))
  #+end_src

  #+RESULTS:
  : STEP-SETTING-SPEC

**** Test
We can quickly check that this code makes what we think

#+begin_src lisp :noweb-ref test-kimia.types
(let (step)
  (setq step
        '(:name :mode
          :type (member :binary :text)
          :default :binary
          :required t
          :doc "The file where the tensor is located"))
  (check-type step step-setting-spec))
#+end_src

#+RESULTS:
: NIL


*** Defining steps

 A step spec has the following syntax, as we have already
 seen

 #+begin_src lisp :eval no
(defstep
  :name name-of-the-step
  :in setting-spec*
  :out setting-spec*)
 #+end_src

For ease of writing these definitions we do not wish
to have proper lists as the value of the =:in= keyword,
so we need a function parsing exactly the =:in= part
and the =:out= part from a list

 #+begin_src lisp :noweb-ref kimia.types
(defun consume-in-out (lst &optional (tail '()))
  (let ((first (car lst))
        (rest (cdr lst)))
    (cond
      ((eq first :out) `(,(reverse tail) ,rest))
      ((eq first :in) (consume-in-out rest tail))
      ((eq lst '()) `(,(reverse tail) ,rest))
      (t (consume-in-out rest (cons first tail))))))

(defun get-keys (lst &optional (rest '()))
  "This function just gets every other element
  "
  (check-type lst (or cons null))
  (let ((head (car lst))
        (tail (cdr lst)))
    (case tail
      ((nil) (reverse rest))
      (otherwise (get-keys (cdr tail)
                           (cons head rest))))))

#+end_src

#+RESULTS:
: GET-KEYS

We still need the definition of a step.

#+begin_src lisp :noweb-ref kimia.types
(defun step-setting-typep (setting-pair setting-spec-list)
  (let* ((key (car setting-pair))
         (value (getf setting-pair key))
         (spec (car (remove-if-not (lambda (s)
                                     (eq key (getf s :name)))
                                   setting-spec-list))))
    (typep value (getf spec :type))))

(defparameter *KIMIA-TYPES* '())
(defmacro defstep (name &rest args)
  ;; checking that name and args are of correct types
  (check-type name (and symbol (not keyword)))
  (let ((inout (consume-in-out args)))
    (dolist (in-or-out inout)
      (dolist (setting in-or-out)
        (check-type setting step-setting-spec))))
  (let* ((type-predicate-name (intern (format nil "~@:(~a~)-P" name)))
         (type-name (intern (format nil "~@:(~a~)" name)))
         (spec-fun-name (intern (format nil "~@:(~a~)-SPEC" name)))
         (default-type-fn (intern (format nil "~@:(~a~)-DEFAULT" name)))
         (c++-name-fn (intern (format nil "~@:(~a~)-C++-NAME" name)))
         (inout (consume-in-out args))
         (in (car inout))
         (in-keys (mapcar (lambda (x) (getf x :name)) in))
         (out (cadr inout)))
    `(progn
       (defun ,c++-name-fn ()
         ,(remove-if (lambda (x) (string= x "-"))
                    (string-capitalize
                     (string-downcase (string name)))))
       (defun ,default-type-fn ()
         '(:name ,name
           :in ,(reduce (lambda (x y) (concatenate 'list x y))
                 (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                  in))
           :out ,(reduce (lambda (x y) (concatenate 'list x y))
                  (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                   out))))
       (defun ,spec-fun-name ()
         '(:name ,name :in ,in :out ,out))
       (defun ,type-predicate-name (thing)
         (check-type thing cons)
         (let* ((-name (getf thing :name))
                (-in (getf thing :in))
                (-in-keys (get-keys -in))
                (-out (getf thing :out))
                (-out-keys (get-keys -out))
                (spec (,spec-fun-name))
                (spec-name (getf spec :name))
                (spec-in (getf spec :in))
                (spec-out (getf spec :out)))
           (and (eq -name spec-name)
                (every (lambda (key)
                         (let* ((value (getf -in key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-in)))
                       -in-keys)
                (every (lambda (key)
                         (let* ((value (getf -out key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-out)))
                       -out-keys))))
       (push ',type-name *KIMIA-TYPES*)
       (deftype ,type-name ()
         '(satisfies ,type-predicate-name)))))
 #+end_src

 #+RESULTS:
 : DEFSTEP

 For instance we can use this macro in the followig manner

 #+begin_src lisp :noweb yes :noweb-ref test-kimia.types
<<defstep-tensor-reader-example>>

(check-type (tensor-reader-default)
            tensor-reader)
 #+end_src

 #+RESULTS:
 : NIL

 and we can make sure that it woks for example as

 #+begin_src lisp :results none :noweb-ref test-kimia.types
(let (step default)
  (setq step
        '(:name Tensor-Reader
          :in (:file "asdf"
               :mode :binary)
          :out (:tensor "Integral")))
  (setq default
        (tensor-reader-default))

  (check-type default tensor-reader)
  (check-type step tensor-reader))
 #+end_src

A very simple macro to check the type of a step is defined below

 #+begin_src lisp :results none :noweb-ref kimia.types
(defmacro check-step-type (step)
  (let ((name (getf step :name)))
    `(let ((step ',step))
       (check-type step ,name))))
#+end_src

which we can use like
#+begin_src lisp :noweb-ref test-kimia.types
(let ((step (tensor-reader-default)))
  (eval `(check-step-type ,step)))
#+end_src

#+RESULTS:
: NIL

*** Making steps

And we just need to create a function to easier create
steps

#+begin_src lisp :results none :noweb-ref kimia.types
(defmacro mk-stepq (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (step `(:name ,name
                 :in ,in
                 :out ,out)))
    `(progn
       (check-step-type ,step)
       ',step
       )))

(defun mk-step (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (type)
         (step)
         )
    (setq type name)
    (setq step `(:name ,name
                 :in ,in
                 :out ,out))
    (eval `(check-step-type ,step))
    step))
 #+end_src

 and we can create a step in the following manner

 #+begin_src lisp :results none :noweb-ref test-kimia.types
(mk-step
 'Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")

(mk-stepq
 Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")
 #+end_src

** Host code generation
*** Introduction

 From a spec, we would like to be able to create autoamtically a
 =struct= that mirror the spec in order to be passed to other functions
 in c++.

 For instance, in the case of the tensor reader, we would
 like to create the following

 #+begin_src cpp :eval yes :includes '(<string> <iostream>)
struct TensorReaderSettings {
  struct In {
    enum Mode {binary, text};
    std::string *file;
    Mode *mode;
    In() {
      mode = new Mode(binary);
      file = nullptr;
    }
  } in;
  struct Out {
    std::string *tensor;
    Out() {
      tensor = new std::string("file.out");
    }
  } out;
};
auto p = TensorReaderSettings::In::Mode::text;
std::cout << p << std::endl;
TensorReaderSettings s;
std::cout << *s.out.tensor << std::endl;
 #+end_src

 #+RESULTS:
 |        1 |
 | file.out |

 together with a converter function from a =cl_object= into
 a =TensorReaderSettings=

 #+begin_src cpp :eval no
TensorReaderSettings
cl_object_to_TensorReaderSettings (cl_object *o) {
}
 #+end_src

 And for these structs we need a functions that from a common lisp
 type constructs a declaration inside the struct or somewhere else.

 First of all we have to make a choice in order to have a simpler
 more maintainable system.
 We will translate every CL type into a poiter of a related type
 in C++, which means that in principle every type can also be =NULL=,
 or =nullptr= in C++.

 There is also the problem of having variables, we should allow
 for symbols to also be passed to any CL variable, they will act as
 named pointers, so that one step can access and modify global data
 that later on other steps can retrieve or further modify.

 | CL type          | C++ interpretation |
 |------------------+--------------------|
 | =string=         | =std::string*=     |
 | =(member :a :b)= | =(enum {a, b})*=   |
 | =integer=        | =int*=             |
 | =double-float=   | =double*=          |
 | =single-float=   | =float*=           |
 | =(list F N)=     | =std::array<F, N>*= |
 | =(list F)=       | =std::vector<F>*=  |
 | =(vector F N)=   | =std::array<F, N>*= |
 | =(vector F)=     | =std::vector<F>*=  |

*** General structure of a type
With this information as motivation we can see in general what we have to do
to use a type from common lisp in the host language.
- Define type (if it is a built-in there is no need).
- Define a constructor.
- Define a declaration.

The C++ programmer may be wondering why we are not considering generic
programming through the templating metaprogramming infrastructure.

The main reason is that creating generic steps would be an added complication
that does not really add much value from the c++ side. Let us suppose
we have a step that might have as a setting a =double= or an =int=
in a polymorphic way.

It is still possible to write our generic function and then define
accordin function pointers or =std::function= to the said functions.

#+begin_src cpp :eval yes :includes '(<string> <iostream> <functional>) :main no :results raw

using StepOneSetting_double = double;
using StepOneSetting_int = int;

template <typename S>
void runStepOne(S s) { std::cout << s << std::endl; }

std::function<void(StepOneSetting_double)>
 runStepOne_double = runStepOne<double>;
std::function<void(StepOneSetting_int)>
 runStepOne_int = runStepOne<StepOneSetting_int>;

int main () {
  runStepOne_double(42.001);
  runStepOne_int(42);
  return 0;
}
#+end_src

#+RESULTS:
42.001
42

*** Type definitions

  #+begin_src lisp

(defparameter *kimia-lower-kinded-types*
  '(string
    integer
    symbol
    keyword))

(defun cl-c++-type-caller (type)
  (let ((name (ecase (type-of type)
                (symbol type)
                (cons (car type)))))
    (funcall (intern (format nil "CL-~@:(~A~)-TO-C++-TYPE" name)) type)))
  #+end_src

  #+RESULTS:
  : CL-C++-TYPE-CALLER

  Some types are high-kinded, in C++ parlance this is akin to
  having template arguments.
  Some types are already defined and some others must be defined.

  #+begin_src lisp
(defun boolean-c++-define (&optional type name) "")
(defun int-c++-define (&optional type name) "")
(defun string-c++-define (&optional type name) "")
(defun single-float-c++-define (&optional type name) "")
(defun double-float-c++-define (&optional type name) "")
(defun vector-c++-define (&optional type name) "")
(defun member-c++-define (&optional type name)
  )
  #+end_src

  #+RESULTS:
  : MEMBER-C++-DEFINE


  #+begin_src lisp
(defun cl-boolean-to-c++-type      (&optional type) "bool")
(defun cl-member-to-c++-type       (&optional type) "enum")
(defun cl-int-to-c++-type          (&optional type) "int")
(defun cl-string-to-c++-type       (&optional type) "std::string")
(defun cl-double-float-to-c++-type (&optional type) "double")
(defun cl-single-float-to-c++-type (&optional type) "single")
(defun cl-vector-to-c++-type (type)
  (check-type type cons)
  (ecase (length type)
    (2 (let ((field (cadr type)))
         (format nil "std::vector<~a>" (cl-c++-type-caller field))))
    (3 "array<F, 5>")))

;; list
;; int
;; single-float
;; double-float
;; complex
;; symbol
;; keyword
;; hashtable
;; vector
;; string
;; pathname
  #+end_src

  #+RESULTS:
  : CL-VECTOR-TO-C++-TYPE



  #+begin_src lisp
(let ((kimia-types *KIMIA-TYPES*)
      (reader (tensor-reader-default))
      (maybe-string '(or string null))
      (s "asdf"))
  (push 'or kimia-types)
  (print kimia-types)
  (eval `(check-step-type ,reader))
  (eval
   `(etypecase ',reader
      (,maybe-string (print "std::string*"))
      (,kimia-types (print "kimia"))
      (t (print "bliad")))))
  #+end_src

  #+RESULTS:
  : kimia


** Testing
#+begin_src lisp :tangle src/clkimia/t.lisp :eval no :noweb no-export
(in-package :kimia)

(in-package :kimia.types)
<<test-kimia.types>>

#+end_src

** The code
 #+begin_src lisp :noweb no-export :tangle src/clkimia/kimia.lisp
(defpackage :kimia.types
  (:use :cl)
  (:nicknames :kt))
(in-package :kimia.types)

<<kimia.types>>

(defpackage :kimia
  (:use :cl)
  (:nicknames :k))
(in-package :kimia)

<<kimia>>

 #+end_src

 #+RESULTS:
 : WRAP-INPUT-SCRIPT
