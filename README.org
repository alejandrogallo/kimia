#+title: Kimia
* =CL-KIMIA=
** Introduction
What should be a good input language for a program?
A case can be made to choose lisp as an input language,
and specially Common Lisp as its dialect.

The fact that =ECL= can be easily embedded in a C or C++
program makes it quite attractive for code where quantum chemical
methods are dealt with or even machine learning codes, where
the abstraction for defining networks could very well be dealt with
through powerful lisp macros.

This document represents an investigation in this direction,
and it is written as a literate program, in the hopes that
it can be embedded in the documentation of an existing program
using =CL-KIMIA= as a powerful input user interface (IUI).

** Wrapping input

In principle we want the current user to use the input language as a
purely recipee based language, like a DSL, so we will wrap the users'
input in a monadic-like interface, where the step will return the
variable ~*KIMIA-STEPS*~ where the steps of the input are stored in
order.

#+begin_src lisp :noweb-ref kimia :eval no :results none
(defparameter *KIMIA-STEPS* '())

(defmacro wrap-input-script (&rest arg)
  `(handler-bind
       ((error #'invoke-debugger))
     (in-package :kimia)
     (progn
       (format t "~%LISP::START evaluating KIMIA script~%")
       ,@arg
       (format t "~%LISP::DONE evaluating KIMIA~%")
       kimia::*KIMIA-STEPS*)))

;(defmacro >> (&rest args)
;  `(push (mk-stepq ,@args) *KIMIA-STEPS*))
#+end_src

** Utils
#+begin_src lisp :noweb-ref kimia
(defun lines (str
              &optional (current-line '()) (rest '())
              &key (sep #\newline))
  (let* ((lst (coerce str 'list))
          (rest-str (coerce (cdr lst) 'string))
          (current-char (car lst)))
    (cond
      ((eq current-char sep)
        (lines rest-str
              '()
              (cons (coerce (reverse current-line) 'string) rest)
              :sep sep))
      ((null current-char)
        (reverse (cons (coerce (reverse current-line) 'string) rest)))
      (t (lines rest-str
                (cons current-char current-line)
                rest
                :sep sep)))))

(defun unlines (lst-str &key (sep "~%"))
  (format nil (format nil "~a~a~a" "~{~a~^" sep "~}") lst-str))

(defun words (str &key (sep #\space))
  (lines str nil nil :sep sep))

(defun unwords (str &key (sep #\space))
  (unlines str :sep sep))

(defun indent (n str &key (sep #\space))
  (format nil
          (format nil
                  "~~{~a~~a~a~~}"
                  (coerce (make-array n :initial-element sep) 'string)
                  "~%")
          (lines str)))
#+end_src

#+RESULTS:
: INDENT

 
** Host code generation
*** Introduction

 From a spec, we would like to be able to create autoamtically a
 =struct= that mirror the spec in order to be passed to other functions
 in c++.

 For instance, in the case of the tensor reader, we would
 like to create the following

 #+begin_src cpp :eval yes :includes '(<string> <iostream>)
struct TensorReaderSettings {
  struct In {
    enum Mode {binary, text};
    std::string *file;
    Mode *mode;
    In() {
      mode = new Mode(binary);
      file = nullptr;
    }
  } in;
  struct Out {
    std::string *tensor;
    Out() {
      tensor = new std::string("file.out");
    }
  } out;
};
auto p = TensorReaderSettings::In::Mode::text;
std::cout << p << std::endl;
TensorReaderSettings s;
std::cout << *s.out.tensor << std::endl;
 #+end_src

 #+RESULTS:
 |        1 |
 | file.out |

 together with a converter function from a =cl_object= into
 a =TensorReaderSettings=

 #+begin_src cpp :eval no
TensorReaderSettings
cl_object_to_TensorReaderSettings (cl_object *o) {
}
 #+end_src

 And for these structs we need a functions that from a common lisp
 type constructs a declaration inside the struct or somewhere else.

 First of all we have to make a choice in order to have a simpler
 more maintainable system.
 We will translate every CL type into a poiter of a related type
 in C++, which means that in principle every type can also be =NULL=,
 or =nullptr= in C++.

 There is also the problem of having variables, we should allow
 for symbols to also be passed to any CL variable, they will act as
 named pointers, so that one step can access and modify global data
 that later on other steps can retrieve or further modify.


*** List of types

 | Built-in CL type | C++ interpretation |
 |------------------+--------------------|
 | =string=         | =std::string=      |
 | =(member :a :b)= | =enum {a, b}=      |
 | =integer=        | =int=              |
 | =double-float=   | =double=           |
 | =single-float=   | =float=            |
 | =(list F N)=     |                    |
 | =(list F)=       |                    |
 | =(vec F N)=      | =std::array<F, N>= |
 | =(vec F)=        | =std::vector<F>=   |
 | =(complex F)=    | =std::complex<F>=  |

 | Kimia CL type                                                    | C++ intepretation               |
 |------------------------------------------------------------------+---------------------------------|
 | =(or symbol null)= through =(-> a)=                              | =a*=                            |
 | =(struct [name] [list of generic variables] ((:name int) ... ))= | =struct [Name] {int name; ...}= |
 | =(enum [name] :a :b ))=                                          | =enum [Name] { A, B, }=         |

- [X] vector
- [X] symbol
- [X] string
- [X] single-float
- [X] keyword
- [X] int
- [X] double-float
- [ ] list
- [ ] hashtable
- [ ] complex



*** Type definitions idea

  Some types are high-kinded, in C++ parlance this is akin to
  having template arguments.
  Some types are already defined and some others must be defined.

- define (type type-name) :: define for the first time.
  - For built-ins in c and c++ this is just empty
  - For structs and enums, if no type-name is given it should be defined in place,
    which is useful for declaring variables.
- declare-var (type type-name var-name) :: declare a variable
  - For built-ins in c and c++ this is just =<type> <var-name>=
  - For structs and enums if no type-name is given then we define the type in place
    If a =type-name= is given then the sentence should be =<type-name> <var-name>=.
- translation ::
  (this also for nameless structs/enums/unions gives the whole struct)
- caster-snippet ::
  This is a snippet of code that should convert in the host language
  a cl_object into a memory address pointing to the object in question.
- caster-name ::
  The name of the caster function

#+begin_src lisp :eval no
(defequiv :c++ (array F integer)
  :translate (lambda (type)
               (let ((field-type (cadr type))
                     (length (caddr type)))
                 (format nil "std::array<~a, ~a>"
                         (c++-translate field-type)
                         length)))
  :declare-var nil ;; default
  :define ""      ;; default
  :caster-name "cl_object_to_array"
  :caster-snippet
  "template <typename F, int N>
  ~a (cl_object o) {
     std::array<F, N> ar;
     ... somehow build ar from o
     return (size_t)new std::array<F, N>(ar);
  }")
#+end_src

*** Define c++ types
**** Naming conventions in C++

#+begin_src lisp :noweb-ref kimia.codegen :results none
(defun endl () (format nil "~%"))

(defun c++-type-name (thing)
  (remove-if (lambda (x) (string= x "-"))
             (string-capitalize
              (string-downcase thing))))

(defun c-type-name (thing)
  (concatenate
   'string
   (substitute #\_ #\-
               (string-downcase thing))
   "_t"))

(defun c++-var-name (thing)
  (nstring-downcase
   (remove-if (lambda (x) (string= x "-"))
              (string-capitalize
               (string-downcase thing)))
   :start 0
   :end 1))

(defun c-var-name (thing)
  (concatenate
   'string
   (substitute #\_ #\-
               (string-downcase thing))))
#+end_src

***** Tests                                                        :noexport:
  #+begin_src lisp :eval no :noweb-ref test-kimia
(assert (string= (c++-type-name 'tensor-reader) "TensorReader"))
(assert (string= (c++-type-name "TeNsor-ReAder") "TensorReader"))
(assert (string= (c-type-name "TeNsor-ReAder") "tensor_reader_t"))
(assert (string= (c++-var-name "TeNsor-ReAder") "tensorReader"))
(assert (string= (c-var-name "TeNsor-ReAder") "tensor_reader"))
  #+end_src

**** =defequiv= macro

and something a little bit more challenging

  #+begin_src lisp :noweb-ref kimia.codegen
(defparameter *KIMIA-TYPES* '())

(defmacro declare-var-fn-default (lang translate)
  (ecase lang
    ((:c :c++)
     `(lambda (ty vn)
        (format nil "~a ~a;"
                (funcall ,translate ty)
                (c++-var-name vn))))))

(eval-when (:compile-toplevel :load-toplevel :execute)

  (defun caster-signature-fmt (lang)
    (ecase lang
      ((:c :c++)
       "~&size_t ~a (const cl_object o)")))

  (defun caster-envelope-fmt (lang)
    (ecase lang
      ((:c :c++)
       (concatenate 'string
                    "~&~a"
                    (caster-signature-fmt lang)
                    "{~&~a~&}"))))

  (defun internal-type-name (type)
    (string-downcase
     (etypecase type
       (cons (format nil "~A-~A"
                     (car type)
                     (length type)))
       (symbol type))))

  (defun defequiv-var-name (lang type)
    (check-type lang keyword)
    (intern (format nil "~@:(~A-~A~)"
                    (internal-type-name type)
                    lang)))

  (defun defequiv-spec (lang type)
    (let ((var (defequiv-var-name lang type)))
      (if (boundp var)
          (eval var)
          (error (format nil "No equivalence found for type ~a for lang ~a"
                         type lang)))))
  )

(defmacro defequiv-alias (lang type from-type)
  (let ((new-spec-name (defequiv-var-name lang type))
        (spec-name (defequiv-var-name lang from-type)))
    `(setq ,new-spec-name ,spec-name)))

(defmacro defequiv-from (lang type &rest args &key from &allow-other-keys)
  (remf args :from)
  (flet ((fun-or-scalar (thing)
           (etypecase thing
             (cons (eval thing))
             (compiled-function thing)
             ((or null string) (eval `(lambda (&optional args)
                                        ,thing))))))
    (let* ((new-spec-name (defequiv-var-name lang type))
           (spec (copy-seq (defequiv-spec lang from)))
           (keys (get-keys args)))
      (dolist (key keys)
        (unless (null (getf args key))
          (setf (getf spec key) (fun-or-scalar (getf args key)))))
      `(setq ,new-spec-name ',spec))))

(defmacro defequiv (lang type
                    &key
                      translate
                      (declare-var nil)
                      (define "")
                      (subtypes nil)
                      (caster-header "")
                      (caster-body "")
                      caster-name
                      caster-snippet)
  (flet ((fun-or-scalar (thing)
           (etypecase thing
             (cons (eval thing))
             (compiled-function thing)
             ((or null string) (eval `(lambda (&optional args)
                                        ,thing))))))
    (let* ((type-lang-name (defequiv-var-name lang type))
           (translate (fun-or-scalar translate))
           (caster-header-f (fun-or-scalar caster-header))
           (caster-name-f (fun-or-scalar caster-name))
           (subtypes-f (fun-or-scalar subtypes))
           (caster-body-f (fun-or-scalar caster-body))
           (caster-snippet-f
             (if caster-snippet
                 (fun-or-scalar caster-snippet)
                 (lambda (ty) (format
                               nil
                               (caster-envelope-fmt lang)
                               (funcall caster-header-f ty)
                               (funcall caster-name-f ty)
                               (indent 2 (funcall caster-body-f ty))))))
           (declare-var (or declare-var (eval
                                         `(declare-var-fn-default ,lang
                                                                  ,translate)))))
      `(progn
         (defparameter ,type-lang-name nil)
         (setq ,type-lang-name
               '(:translate ,translate
                 :declare-var ,(fun-or-scalar declare-var)
                 :define ,(fun-or-scalar define)
                 :subtypes ,subtypes-f
                 :caster-header ,caster-header-f
                 :caster-name ,caster-name-f
                 :caster-body ,caster-body-f
                 :caster-snippet ,caster-snippet-f)))
      )))

;; TODO: generalize these funcs
(defun caster-snippet (lang ty)
  (let ((spec (defequiv-spec lang ty)))
    (funcall (getf spec :caster-snippet) ty)))

(defun subtypes (lang ty)
  (let* ((spec (defequiv-spec lang ty))
         (subtypes (funcall (getf spec :subtypes) ty)))
    subtypes))

(defun caster-body (lang ty)
  (let ((spec (defequiv-spec lang ty)))
    (funcall (getf spec :caster-body) ty)))

(defun caster-name (lang ty)
  (let ((spec (defequiv-spec lang ty)))
    (funcall (getf spec :caster-name) ty)))

(defun translate (lang ty)
  (let ((spec (defequiv-spec lang ty)))
    (funcall (getf spec :translate) ty)))

(defun define (lang ty)
  (let ((spec (defequiv-spec lang ty)))
    (funcall (getf spec :define) ty)))

(defun declare-var (lang ty vn)
  (let ((spec (defequiv-spec lang ty)))
    (funcall (getf spec :declare-var) ty vn)))

(defun caster-signature (lang ty)
  (let ((fmt (format nil "~a;" (caster-signature-fmt lang))))
    (format nil
            fmt
            (caster-name lang ty))))
  #+end_src

  #+RESULTS:
  : CASTER-SIGNATURE


***** Tests

#+begin_src lisp :eval no :noweb-ref test-kimia
(dolist (lang '(:c :c++))
  ;; caster-signature-fmt
  (assert-equal (caster-signature-fmt lang) "~&size_t ~a (const cl_object o)")
  ;; caster-envelope-fmt
  (assert-equal (caster-envelope-fmt lang)
                "~&~a~&size_t ~a (const cl_object o){~&~a~&}"))

;; internal-type-name
(assert-equal (internal-type-name 'integer)
              "integer")
(assert-equal (internal-type-name '(struct something asdf ))
              "struct-3")

;; defequiv-var-name
(assert-eq (defequiv-var-name :c '(struct something asdf ))
           'STRUCT-3-C)
(assert-eq (defequiv-var-name :c++ '(struct something asdf ))
           'STRUCT-3-C++)

;; defequiv-var-name
(assert-eq (defequiv-var-name :c++ '(vec F N))
           'vec-3-c++)
(assert-eq (defequiv-var-name :c '(struct name (vars) (fields)))
           'struct-4-c)
(assert-eq (defequiv-var-name :c '(struct name (vars) (fields)))
           'struct-4-c)
(assert-eq (defequiv-var-name :c++ 'integer)
           'integer-c++)
(assert-eq (defequiv-var-name :c 'integer)
           'integer-c)
#+end_src


*** Simple types

#+begin_src lisp :noweb-ref kimia.codegen :results none
(defequiv :c++ integer
  :translate "int"
  :caster-name (lambda (ty) (format nil "cl~a" (translate :c++ ty)))
  :caster-body (lambda (ty)
                    (format nil "return (size_t)new int(ecl_to_int(o));"
                            (translate :c++ ty))))

(defequiv :c++ double-float
  :translate "double"
  :caster-name (lambda (ty) (format nil "cl~a" (translate :c++ ty)))
  :caster-body "return (size_t)new double(ecl_to_double(o));")

(defequiv :c++ single-float
  :translate "float"
  :caster-name (lambda (ty) (format nil "cl~a" (translate :c++ ty)))
  :caster-body "return (size_t)new float(ecl_to_float(o));")

(defequiv :c++ boolean
  :translate "bool"
  :caster-name (lambda (ty) (format nil "cl~a" (translate :c++ ty)))
  :caster-body "return (size_t)new bool(ecl_to_bool(o));")

;; TODO: caster body
(defequiv :c++ string
  :translate "std::string"
  :caster-body "const size_t dimension(o->base_string.dim);
                std::string result;
                ecl_base_char* c = o->base_string.self;
                // TODO: handle the unicode well.
                // right now I know it is 32bit characters,
                // that is why the i * 4 is there
                for (size_t i = 0; i < dimension; i++)
                  result += *(c + i * 4);
                return (size_t)new std::string(result);"

  :caster-name "clstr")
#+end_src

**** Tests                                                         :noexport:
#+begin_src lisp :eval no :noweb-ref test-kimia
(assert-equal (translate :c++ 'integer) "int")
(assert-equal (translate :c++ 'double-float) "double")
(assert-equal (translate :c++ 'single-float) "float")
(assert-equal (translate :c++ 'boolean) "bool")
(assert-equal (translate :c++ 'string) "std::string")

(assert-equal (declare-var :c++ 'integer 'this-is-a-variable)
              "int thisIsAVariable;")

(assert-equal (declare-var :c++ 'integer 'this-is-a-variable)
              "int thisIsAVariable;")

(assert-equal (caster-snippet :c++ 'double-float)
"size_t cldouble (const cl_object o){
  return (size_t)new double(ecl_to_double(o));
}")

#+end_src


*** Vectors

This is the cpp snippet to convert a common lisp vector into
another vector
#+begin_src cpp :noweb-ref vector-cpp-body :eval no
~a result~a;
for (size_t i=0; i < result.size(); i++) {
  cl_object index(c_string_to_object(std::to_string(i).c_str()));
  ~a *element = (~a*)~a(cl_aref(2, o, index));
  result[i] = *element;
}
return (size_t)new ~a(result);
#+end_src

and for the main definitions

#+begin_src lisp :noweb-ref kimia.codegen :noweb no-export :results none
(defparameter +c++-vector-body+
"~
<<vector-cpp-body>>")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun vector-body-c++ (ty &key (array nil))
    (format nil
            +c++-vector-body+
            (translate :c++ ty)
            (if array "" "(ecl_to_int(cl_length(o)))")
            (translate :c++ (cadr ty))
            (translate :c++ (cadr ty))
            (caster-name :c++ (cadr ty))
            (translate :c++ ty))))


(defun vec-p (F v)
  (every (lambda (x) (typep x F))
         v))

(deftype vec (F &optional N)
  `(and (array * (,N)) ; take care of the types in vec
    (satisfies ,(lambda (x) (vec-p F x)) )))

(defequiv :c++ (vec F)
  :translate (lambda (ty)
               (format nil "std::vector< ~a >"
                       (translate :c++ (cadr ty))))

  :subtypes (lambda (ty) `(,(cadr ty)))

  :caster-name (lambda (ty)
                 (format nil "v_of_~a"
                         (caster-name :c++ (cadr ty))))

  :caster-header (lambda (ty) (caster-signature :c++ (cadr ty)))

  :caster-body #'vector-body-c++)

(defequiv :c++ (vec F N)

  :translate (lambda (ty)
               (format nil "std::array< ~a, ~a >"
                       (translate :c++ (cadr ty))
                       (caddr ty)))

  :subtypes (lambda (ty) `(,(cadr ty)))

  :caster-name (lambda (ty)
                 (format nil "ar_of_~a_~a"
                         (caddr ty)
                         (caster-name :c++ (cadr ty))))
  :caster-body
  (lambda (ty)
    (vector-body-c++ ty :array t)))


#+end_src

**** Tests

#+begin_src lisp :eval no :noweb-ref test-kimia
(assert-equal (translate :c++ '(vec double-float))
              "std::vector< double >")
(assert-equal (translate :c++ '(vec (g 5)))
              "std::vector< _G5 >")
(assert-equal (translate :c++ '(vec (g 5) 8))
              "std::array< _G5, 8 >")
(assert-equal (translate :c++ '(vec (vec (vec double-float) 2) 8))
              "std::array< std::array< std::vector< double >, 2 >, 8 >")

;;; CASTING
(assert-equal (caster-name :c++ '(vec integer 8))
              "ar_of_8_clint")

(assert-equal (caster-snippet :c++ '(vec integer))
"size_t clint (const cl_object o);
size_t v_of_clint (const cl_object o){
  std::vector< int > result(ecl_to_int(cl_length(o)));
  for (size_t i=0; i < result.size(); i++) {
    cl_object index(c_string_to_object(std::to_string(i).c_str()));
    int *element = (int*)clint(cl_aref(2, o, index));
    result[i] = *element;
  }
  return (size_t)new std::vector< int >(result);
}")

(assert-equal (caster-name :c++ '(vec (vec double-float) 8))
              "ar_of_8_v_of_cldouble")

(assert-equal (caster-snippet :c++ '(vec (vec double-float) 8))
"size_t ar_of_8_v_of_cldouble (const cl_object o){
  std::array< std::vector< double >, 8 > result;
  for (size_t i=0; i < result.size(); i++) {
    cl_object index(c_string_to_object(std::to_string(i).c_str()));
    std::vector< double > *element = (std::vector< double >*)v_of_cldouble(cl_aref(2, o, index));
    result[i] = *element;
  }
  return (size_t)new std::array< std::vector< double >, 8 >(result);
}")
#+end_src



*** Generic variables

#+begin_src lisp :noweb-ref kimia.codegen
;; generic variables
(defequiv :c++ (G N)
  :translate (lambda (ty)
               (format nil "_G~a" (cadr ty))))

(defun generic-p (type)
  (etypecase type
    (cons (eq 'g (car type)))
    (t nil)))
#+end_src

#+RESULTS:
: GENERIC-P

**** Tests
#+begin_src lisp :eval no :noweb-ref test-kimia
(assert (generic-p '(g 5)))
(assert (generic-p '(g a)))
(assert (not (generic-p '(vec F))))
(assert-equal (translate :c++ '(g a))
              "_GA")
(assert-equal (translate :c++ '(g 98))
              "_G98")
#+end_src


*** Pointers and const

Also pointers and const qualifiers have to be implemented.

#+begin_src lisp :noweb-ref kimia.codegen :results none
(defun pointer-p (ty ps)
  (and (eq (car ps) 'pointer)
       (let ((value (cadr ps)))
         (etypecase value
           (symbol (if (boundp value)
                       (typep (eval value) ty)
                       t))
           (t (typep value ty))))))

(deftype pointer (type-pointed-to)
  `(and cons
        (satisfies ,(lambda (x) (pointer-p type-pointed-to x)))))

;; TODO: create the real caster body
(defequiv :c++ (pointer F)
  :translate (lambda (ty) (format nil "~a*" (translate :c++ (cadr ty))))
  :caster-body (lambda (ty) (format nil "return (size_t)new size_t(~a(o));"
                                    (caster-name :c++ (cadr ty))))
  :subtypes (lambda (ty) `(,(cadr ty)))
  :caster-header (lambda (ty) (caster-signature :c++ (cadr ty)))
  :caster-name (lambda (ty) (format nil "p~a" (caster-name :c++ (cadr ty)))))

(deftype const (type-pointed-to)
  `(satisfies ,(lambda (x) (typep x type-pointed-to))))

(defequiv :c++ (const F)
  :translate (lambda (ty) (format nil "const ~a" (translate :c++ (cadr ty))))
  :caster-name (lambda (ty) (format nil "c~a" (caster-name :c++ (cadr ty))))
  :subtypes (lambda (ty) `(,(cadr ty)))
  :caster-header (lambda (ty) (caster-signature :c++ (cadr ty)))
  :caster-body (lambda (ty) (caster-body :c++ (cadr ty))))
#+end_src

**** Tests

#+begin_src lisp :eval no :noweb-ref test-kimia
;; undbound symbols are pointers to anything
(assert (typep `(pointer ,(gensym)) '(pointer integer)))
(assert (typep `(pointer ,(gensym)) '(pointer lala)))
(defparameter *test-mypointer* 5)
(let ((myint 5898))
  (check-type `(pointer ,myint)
              (pointer integer))
  (check-type '(pointer *test-mypointer*)
              (pointer integer))
  (assert (typep '(pointer *test-mypointer*) '(pointer integer)))
  (assert (typep '(pointer 5) '(pointer integer)))
  (assert-not (typep '(pointer 5.5) '(pointer integer)))
  (assert-not (typep '(pointer 5.5d0) '(pointer integer)))
  (assert (typep '(pointer 5.5d0) '(pointer double-float)))
  (assert-not (typep '(pointer 5.5) '(pointer double-float)))
  (assert (typep '(pointer myint) '(pointer integer)))
  (let ((*test-mypointer* 5.5))
    (assert-not (typep '(pointer *test-mypointer*)
                       '(pointer integer)))))

(assert-equal (translate :c++ '(pointer integer))
              "int*")
(assert-equal (translate :c++ '(pointer (vec (pointer (pointer integer)))))
              "std::vector< int** >*")


;;;; const
(assert (typep 5 '(const integer)))
(assert-not (typep 5.5 '(const integer)))

(assert-equal (translate :c++ '(const integer)) "const int")
(assert-equal (translate :c++ '(const (vec (pointer (const integer)))))
              "const std::vector< const int* >")
;; the casters should be the same really
(assert-equal (caster-snippet :c++ '(const double-float))
"size_t cldouble (const cl_object o);
size_t cldouble (const cl_object o){
  return (size_t)new double(ecl_to_double(o));
}")
#+end_src


*** The struct

The most central data structure to start doing complex behaviour
is the =struct= or =class=.
In common lisp, we will consider a struct as a type as being of the form

#+begin_src lisp :eval no
(struct name-of-struct-type
  (:name-of-field-1 type-of-field-1
   :name-of-field-2 type-of-field-2
   ...))
#+end_src

and the name of the struct can be a list with
generic data types:


#+begin_src lisp :noweb-ref kimia.codegen :results none
(eval-when (:compile-toplevel :load-toplevel :execute)

  (defun struct-spec-p (ty)
    (and (eq (car ty) 'struct)
         (typep (cadr ty) '(or cons symbol))
         (typep (caddr ty) '(or cons symbol))
         (eql (length ty) 3)))

  (defun struct-identifier-p (ty)
    (and (eq (car ty) 'struct)
         (typep (cadr ty) '(or cons symbol))
         (eql (length ty) 2)))

  (deftype struct-identifier ()
    '(and cons
      (satisfies struct-identifier-p)))

  (deftype struct-spec ()
    '(and cons
      (satisfies struct-spec-p)))

  (defun struct-spec-name (ty)
    (check-type ty (or struct-spec struct-identifier))
    (let ((name (cadr ty)))
      (typecase name
        (symbol name)
        (cons (car name)))))

  (defun struct-spec-generic-vars (ty)
    (check-type ty (or struct-spec struct-identifier))
    (etypecase (cadr ty)
      (cons (cdadr ty))
      (t nil)))

  (defun struct-spec-fields (ty)
    (check-type ty struct-spec)
    (caddr ty))

  (defun struct-template-line (ty)
    (check-type ty (or struct-spec struct-identifier))
    (let ((gvars (struct-spec-generic-vars ty)))
      (if gvars
          (if (remove-if-not #'generic-p gvars)
              (format nil "template < ~{typename ~a~^, ~} >"
                      (mapcar (lambda (x) (translate :c++ x)) gvars))
              "template")
          "")))

  (defun struct-spec-symbol (struct-name)
    (check-type struct-name (or symbol string))
    (intern
     (format nil "~@:(~A-SPEC~)"
             struct-name)))

  (defun struct-spec-subtypes (spec)
    (etypecase spec
      (struct-spec (mapcar #'cadr (struct-spec-fields spec)))
      (struct-identifier (let* ((name (struct-spec-name spec))
                                (spec-symbol (struct-spec-symbol name))
                                (spec (eval spec-symbol)))
                           (struct-spec-subtypes spec)))))

  (defun rec-subst (ls what)
    (check-type ls list)
    (check-type what cons)
    (let ((pair (car ls)))
      (etypecase pair
        (null what) ;; We are done
        (cons (rec-subst (cdr ls)
                         (subst (car pair) (cdr pair) what))))))

  (defun struct-unnamed-p (ty)
    (and (typep ty '(or struct-spec struct-identifier))
         (null (struct-spec-name ty))))

  (defun struct-get-spec (ty)
    (check-type ty (or struct-spec struct-identifier))
    (if (struct-unnamed-p ty)
        ty
        (eval (struct-spec-symbol (struct-spec-name ty)))))

  (defun struct-get-expanded-spec (ty)
    (let* ((spec (struct-get-spec ty))
           (gvars (struct-spec-generic-vars ty))
           (spec-gvars (struct-spec-generic-vars spec))
           (equivalence-list (pairlis gvars spec-gvars)))
      (if equivalence-list
          (rec-subst equivalence-list spec)
          spec)))

  (defun struct-spec-generic-p (spec)
    (check-type spec (or struct-spec struct-identifier))
    (let ((gvars (struct-spec-generic-vars spec)))
      (remove-if-not #'generic-p gvars)))

  (defun translate-struct-c++ (ty)
    (let* ((ty-name (struct-spec-name ty))
           (name (if ty-name (c++-type-name ty-name) ""))
           (specialized-spec (struct-get-expanded-spec ty))
           (fields (struct-spec-fields specialized-spec))
           (gvars (struct-spec-generic-vars specialized-spec))
           (is-generic (struct-spec-generic-p specialized-spec)))
      (format nil "~&~a~&struct ~a~a~a"
              (struct-template-line ty)
              (or name "")
              (cond
                ((and gvars
                      (not is-generic))
                 (format nil "< ~{~a~^, ~} >"
                         (mapcar (lambda (ty) (translate :c++ ty))
                                 gvars)))
                (t
                 (format nil " {~{~&~a~}}"
                         (loop for kp in fields
                               collect
                               (indent 2
                                       (declare-var :c++ (cadr kp) (car kp)))))))
              (if (struct-unnamed-p ty) "" ";"))))

  (defun struct-pre-var-c++ (ty)
    (let* ((ty-name (struct-spec-name ty))
           (is-unnamed (struct-unnamed-p ty))
           (pre-var (if is-unnamed
                        (translate-struct-c++ ty)
                        (c++-type-name ty-name)))
           (gvars (struct-spec-generic-vars ty)))
      (format nil "~a~a"
              pre-var
              (if (and gvars (not is-unnamed))
                  (format nil "< ~{~a~^, ~} >"
                          (mapcar (lambda (x) (translate :c++ x))
                                  gvars))
                  ""))))

  (defun declare-var-struct-c++ (ty vn)
    (let* ((pre-var (struct-pre-var-c++ ty)))
      (format nil "~a ~a;"
              pre-var
              (c++-var-name vn))))

  (defun define-struct-c++ (ty)
    (translate-struct-c++ ty))

  (defun get-keys (lst &optional (rest '()))
    "This function just gets every other element
  "
    (check-type lst (or cons null))
    (let ((head (car lst))
          (tail (cdr lst)))
      (case tail
        ((nil) (reverse rest))
        (otherwise (get-keys (cdr tail)
                             (cons head rest))))))

  (defun struct-check-type (ty cons-struct)
    (check-type cons-struct cons)
    (check-type ty (or struct-spec struct-identifier))
    (let* ((spec (struct-get-expanded-spec ty))
           (fields (struct-spec-fields spec)))
      (notany #'null
              (mapcar (lambda (key) (let ((type (assoc key fields)))
                                      (typep (getf cons-struct key)
                                             (getf type key))))
                      (get-keys cons-struct)))))

  (defun struct-caster-name (ty)
    (let* ((name (struct-spec-name ty))
           (spec (struct-get-expanded-spec ty))
           (gvars (struct-spec-generic-vars spec))
           (is-unnamed (struct-unnamed-p ty))
           (subtypes (mapcar #'cadr (struct-spec-fields spec)))
           (is-generic (struct-spec-generic-p spec)))
      (when is-generic (error "Cannot create a caster for generic struct"))
      ;(when is-unnamed (error "Can't create a caster name for unnamed structs"))
      (if gvars
          (format nil "s_~a_with_~{~a~^_and_~}"
              (c-var-name name)
              (mapcar (lambda (x) (caster-name :c++ x)) gvars))
          (format nil "s_~a" (c-var-name name)))))

  (defun struct-caster-body-of-unnamed-struct (spec parent-key
                                               &key (cl-object "o"))
    (format nil
            "{~&~{~&~a~^,~}~&} /* unnamed */"
            (struct-caster-body-from-subtypes
             spec
             :cl-object
             (format nil
                     "cl_getf(2, ~a, c_string_to_object(\"~s\"))"
                     cl-object
                     parent-key))))

  (defun struct-caster-body-from-subtypes (spec &key (cl-object "o"))
    (check-type spec struct-spec)
    (let* ((fields (struct-spec-fields spec))
           (subtypes (mapcar #'cadr fields))
           (format-arguments
             (mapcar (lambda (ty x y z) `(,ty
                                          ,x
                                          ,y
                                          ,z))
                     subtypes
                     (mapcar (lambda (x) (translate :c++ x)) subtypes)
                     (mapcar (lambda (x) (caster-name :c++ x)) subtypes)
                     (mapcar (lambda (x) (car x)) fields)
                     ))
           (is-generic (struct-spec-generic-p spec))
           (is-unnamed (struct-unnamed-p spec)))
      (mapcar (lambda (x)
                (cond
                  ;; Check for const unnamed structs
                  ((and (consp (car x))
                        (eq (caar x) 'const)
                        (typep (cadar x) '(or struct-identifier struct-spec))
                        (struct-unnamed-p (cadar x)))
                   (indent 2 (struct-caster-body-of-unnamed-struct
                              (cadar x) (cadddr x) :cl-object cl-object)))
                  ;; What happens if we have an unnamed struct??
                  ;; we can not really have a caster function
                  ;; in general for those
                  ((and (typep (car x) 'struct-spec)
                        (struct-unnamed-p (car x)))
                   (indent 2 (struct-caster-body-of-unnamed-struct
                              (car x) (cadddr x) :cl-object cl-object)))
                  ;; Regular types
                  (t (format
                      nil
                      (format
                       nil
                       "~?"
                       ;; v------ignore first x   v--- cl-object
                       "  ~**(~a*)~a(cl_getf(2, ~~a, c_string_to_object(\"~s\")))"
                       ;;          ^--caster name          struct key -----^
                       x)
                      cl-object))))
              format-arguments)
      ))

  (defun struct-caster-body (ty)
    (let* ((spec (struct-get-expanded-spec ty))
           (is-generic (struct-spec-generic-p spec))
           (constructor (struct-caster-body-from-subtypes spec)))
      (when is-generic (error "Cannot create a caster for generic struct"))
      (format nil "return (size_t)new ~a{~&~{~&~a~^,~}~&};"
              (struct-pre-var-c++ spec)
              constructor)))

  (defun struct-caster-header (ty)
    (let* ((subtypes (subtypes :c++ ty)))
      (format nil "~{~a~^~%~}"
              (mapcar (lambda (x)
                        (caster-signature :c++ x))
                      (remove-if #'struct-unnamed-p subtypes)))))

  )

(defmacro defgenericstruct (name spec)
  (let* ((spec `(struct ,name ,spec))
         (struct-name (struct-spec-name spec))
         (struct-spec-var (struct-spec-symbol struct-name)))
    `(progn
       (defparameter ,struct-spec-var ',spec))))

(defequiv :c++ (struct name)
  :translate (lambda (ty) (translate-struct-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-struct-c++ ty vn))
  :define (lambda (ty) (define-struct-c++ ty))
  :subtypes #'struct-spec-subtypes
  :caster-name #'struct-caster-name
  :caster-header #'struct-caster-header
  :caster-body #'struct-caster-body)

;; unnamed structs
(defequiv :c++ (struct nil spec)
  :translate (lambda (ty) (translate-struct-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-struct-c++ ty vn))
  :define (lambda (ty) (define-struct-c++ ty))
  :subtypes #'struct-spec-subtypes
  :caster-name #'struct-caster-name
  :caster-header #'struct-caster-header
  :caster-body #'struct-caster-body)

(deftype struct (name)
  `(and cons
        (satisfies ,(lambda (x)
                      (struct-check-type `(struct ,name) x)))))
#+end_src

**** Tests

#+begin_src lisp :eval no :noweb-ref test-data-kimia
(defgenericstruct
    tensor-reader-double
    ((:name string)
     (:lens (vec double-float))))

(defgenericstruct
    (tensor-reader F)
    ((:name string)
     (:lens (vec F))))

(defgenericstruct
    (davidson-solver A B tensor-field D)
    ((:vectorspace A)
     (:fields (vec B))
     (:lens (vec tensor-field))
     (:mask-tensor (vec tensor-field))
     (:dimension (vec (vec (vec D)) 5))))

(defgenericstruct
    (Uttu F)
    ((:name F)))

(defgenericstruct
    with-unnammed
    ((:name string)
     (:lens (struct nil ((:lens integer))))))

(defgenericstruct
    with-unnammed-and-simple
    ((:name string)
     (:author (struct nil ((:name string))))
     (:lens (struct with-unnamed))))

;; this example is the MONSTER-STRUCT
(defgenericstruct
    (monster-struct A B C)
    ((:name string)
     (:data (pointer (vec A)))
     (:connection (struct nil ((:ip (struct nil
                                            ((:ipv4 A)
                                             (:ipv6 integer))))
                               (:timeout B))))
     (:components (struct nil
                          ((:pphh (vec A))
                           (:pppp (vec A))
                           (:hhhh (vec A))
                           (:lens (const (vec A))))))
     (:in (const (struct nil ((:date (pointer C))))))
     (:lens (vec B))))
#+end_src

#+begin_src lisp :eval no :noweb-ref test-kimia
(assert tensor-reader-double-spec)
(check-type tensor-reader-double-spec struct-spec)

;; struct-spec-name ;;;;;;;;;;;;;;;
(assert-eq (struct-spec-name tensor-reader-double-spec)
           'tensor-reader-double)
(assert-eq (struct-spec-name '(struct tensor-reader-double))
           'tensor-reader-double)
;; spec
(assert-eq (struct-spec-name '(struct (tensor-reader-double A F) some))
           'tensor-reader-double)
;; identifier
(assert-eq (struct-spec-name '(struct (tensor-reader-double A F)))
           'tensor-reader-double)
;; unnammed
(assert-eq (struct-spec-name '(struct (nil A F)))
           nil)

;; SPEC FIELDS ;;;;;;;;;;;
(assert-equal (struct-spec-fields (eval (struct-spec-symbol
                                         'tensor-reader-double)))
              (caddr tensor-reader-double-spec))

;; template line

(assert-equal (struct-template-line '(struct tensor-reader-double))
              "")
(assert-equal (struct-template-line '(struct (tensor-reader integer)))
              "template")
(assert-equal (struct-template-line '(struct (tensor-reader (g 5))))
              "template < typename _G5 >")
(assert-equal (struct-template-line '(struct
                                      (davidson-solver
                                       (g 1) (g 2) (g 3) (g 4))))
              "template < typename _G1, typename _G2, typename _G3, typename _G4 >")

;;; get spec
(assert-equal (struct-get-spec '(struct (davidson-solver F G H A)))
              davidson-solver-spec)

;; struct-spec-generic-vars
(assert-equal (struct-spec-generic-vars '(struct (davidson-solver
                                                  (g 1) (g 2) (g 3) (g 4))))
              '((g 1) (g 2) (g 3) (g 4)))
(assert-equal (struct-spec-generic-vars '(struct (davidson-solver
                                                  integer double lala F)))
              '(integer double lala F))

;; struct-spec-generic-p
(assert (struct-spec-generic-p
         '(struct (davidson-solver (g 1) (g 2) (g 3) (g 4)))))
(assert (struct-spec-generic-p
         '(struct (davidson-solver integer (g 2) (g 3) (g 4)))))
(assert (struct-spec-generic-p
         '(struct (davidson-solver integer string (g 3) (g 4)))))
(assert (struct-spec-generic-p
         '(struct (davidson-solver integer string integer (g 4)))))
(assert-not (struct-spec-generic-p
             '(struct (davidson-solver integer string integer integer))))

;; get-keys
(assert-equal (get-keys '(:asdf 5 :err 98))
              '(:asdf :err))
(assert-equal (get-keys '(:asdf 5 :err))
              '(:asdf))

(struct-get-expanded-spec '(struct tensor-reader-double))

;; TYPE CHECKING
(assert (struct-check-type '(struct tensor-reader-double)
                           '(:name "hello world" :lens #(5.0d0 9.0d0))))
(assert-not (struct-check-type '(struct tensor-reader-double)
                               '(:name "hello world" :lens #(5.0d0 9.0))))
(assert-not (struct-check-type '(struct tensor-reader-double)
                               '(:name 5 :lens #(5.0d0 9.0d0))))

(assert (typep '(:name 654.5d0)
               '(struct (Uttu double-float))))
(assert-not (typep '(:name 654.5d0)
                   '(struct (Uttu integer))))

(assert (typep '(struct (Uttu integer))
               'struct-identifier))
(assert-not (typep '(struct (Uttu integer))
                   'struct-spec))

;;;;; CODE GENERATION
(assert-equal
 (translate :c++ '(struct (uttu string)))
 "template
struct Uttu< std::string >;")

(assert-equal
 (translate :c++ '(struct (uttu (g 5))))
 "template < typename _G5 >
struct Uttu {
  _G5 name;
};")

(assert-equal (caster-signature :c++ '(struct (uttu integer)))
              "size_t s_uttu_with_clint (const cl_object o);")

(assert-equal (caster-snippet :c++ '(struct (uttu integer)))
"size_t clint (const cl_object o);
size_t s_uttu_with_clint (const cl_object o){
  return (size_t)new Uttu< int >{
    ,*(int*)clint(cl_getf(2, o, c_string_to_object(\":NAME\")))
  };
}")


(assert-equal (translate :c++ '(struct (monster-struct (g DA) (g OI) (g vec ))))
"template < typename _GDA, typename _GOI, typename _GVEC >
struct MonsterStruct {
  std::string name;
  std::vector< _GDA >* data;
  struct  {
    struct  {
      _GDA ipv4;
      int ipv6;
    } ip;
    _GOI timeout;
  } connection;
  struct  {
    std::vector< _GDA > pphh;
    std::vector< _GDA > pppp;
    std::vector< _GDA > hhhh;
    const std::vector< _GDA > lens;
  } components;
  const struct  {
    _GVEC* date;
  } in;
  std::vector< _GOI > lens;
};")

(assert-equal
 (translate :c++ '(struct (monster-struct integer double-float single-float)))
 "template
struct MonsterStruct< int, double, float >;")

(typep '(pointer (struct monster-struct))
       '(or (pointer struct-identifier) (pointer struct-spec)))

(typep '(const (struct monster-struct))
       '(or (const struct-identifier) (const struct-spec)))

(assert-equal
 (caster-snippet :c++ '(struct (monster-struct integer double-float single-float)))
"size_t clstr (const cl_object o);
size_t pv_of_clint (const cl_object o);
size_t s_nil (const cl_object o);
size_t s_nil (const cl_object o);
size_t s_nil (const cl_object o);
size_t v_of_cldouble (const cl_object o);
size_t s_monster_struct_with_clint_and_cldouble_and_clfloat (const cl_object o){
  return (size_t)new MonsterStruct< int, double, float >{
    ,*(std::string*)clstr(cl_getf(2, o, c_string_to_object(\":NAME\"))),
    ,*(std::vector< int >**)pv_of_clint(cl_getf(2, o, c_string_to_object(\":DATA\"))),
    {
      {
        ,*(int*)clint(cl_getf(2, cl_getf(2, cl_getf(2, o, c_string_to_object(\":CONNECTION\")), c_string_to_object(\":IP\")), c_string_to_object(\":IPV4\"))),
        ,*(int*)clint(cl_getf(2, cl_getf(2, cl_getf(2, o, c_string_to_object(\":CONNECTION\")), c_string_to_object(\":IP\")), c_string_to_object(\":IPV6\")))
      } /* unnamed */
    ,
      ,*(double*)cldouble(cl_getf(2, cl_getf(2, o, c_string_to_object(\":CONNECTION\")), c_string_to_object(\":TIMEOUT\")))
    } /* unnamed */
  ,
    {
      ,*(std::vector< int >*)v_of_clint(cl_getf(2, cl_getf(2, o, c_string_to_object(\":COMPONENTS\")), c_string_to_object(\":PPHH\"))),
      ,*(std::vector< int >*)v_of_clint(cl_getf(2, cl_getf(2, o, c_string_to_object(\":COMPONENTS\")), c_string_to_object(\":PPPP\"))),
      ,*(std::vector< int >*)v_of_clint(cl_getf(2, cl_getf(2, o, c_string_to_object(\":COMPONENTS\")), c_string_to_object(\":HHHH\"))),
      ,*(const std::vector< int >*)v_of_clint(cl_getf(2, cl_getf(2, o, c_string_to_object(\":COMPONENTS\")), c_string_to_object(\":LENS\")))
    } /* unnamed */
  ,
    {
      ,*(float**)pclfloat(cl_getf(2, cl_getf(2, o, c_string_to_object(\":IN\")), c_string_to_object(\":DATE\")))
    } /* unnamed */
  ,
    ,*(std::vector< double >*)v_of_cldouble(cl_getf(2, o, c_string_to_object(\":LENS\")))
  };
}")
#+end_src


*** The enums
    
#+begin_src lisp :noweb-ref kimia.codegen
(defun translate-enum-c++ (ty)
  (let* ((ty-name (cadr ty))
         (name (if ty-name (c++-type-name ty-name) ""))
         (fields (cddr ty)))
    (concatenate 'string
                 "enum "
                 (or name "")
                 " {"
                 (endl)
                 (eval
                  `(concatenate 'string
                                ,@(loop for kp in fields
                                        collect
                                        (format nil
                                                "  ~a,~a"
                                                kp
                                                (endl)))))
                 "}")))

(defun declare-var-enum-c++ (ty vn)
  (let* ((name (cadr ty))
         (fields (caddr ty))
         (pre-var (etypecase name
                    (null (translate-enum-c++ ty))
                    (t (string-capitalize name)))))
    (format nil "~a ~a;" pre-var (c++-var-name vn))))

(defun define-enum-c++ (ty)
  (format nil "~a;" (translate-enum-c++ ty)))

(defequiv :c++ (enum name args)
  :translate (lambda (ty) (translate-enum-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-enum-c++ ty vn))
  :define (lambda (ty) (define-enum-c++ ty)))

(defequiv :c++ (member args)
  :translate (lambda (ty)
               (translate-enum-c++ `(enum nil ,@(cdr ty))))
  :declare-var (lambda (ty vn)
                 (declare-var-enum-c++ `(enum nil ,@(cdr ty)) vn))
  :define (lambda (ty)
            (define-enum-c++ `(enum nil ,@(cdr ty)))))
#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x3f34cd0> :DECLARE-VAR
:  #<bytecompiled-function 0x4264550> :DEFINE #<bytecompiled-function 0x4264460>
:  :SUBTYPES #<bytecompiled-function 0x42f90f0> :CASTER-HEADER
:  #<bytecompiled-function 0x42f9000> :CASTER-NAME
:  #<bytecompiled-function 0x42f90a0> :CASTER-BODY
:  #<bytecompiled-function 0x42f9140> :CASTER-SNIPPET
:  #<bytecompiled-closure #<bytecompiled-function 0x48d54b0>>)



*** Run steps in C++

- we only have fields of structs to allocate or not
- we allocate all of them with new and store the address in
  the database (=map<string, size_t>=)
- then pseudocode

**** Initializing data structures

The main pseudocode would look like this

   #+begin_src python :eval no
parsed-steps = vector<string, string>; (step symbol, step name)
runner-database = vector<string, size_t>; (algo name , address to runner function)

for step-settings in steps:
      step-field-symbols = []
      for field in step-field:
          is field a symbol?
              is symbol in database?
                  step-field-symbols.append(symbol)
              else
                  v = value of symbol (should have been typechecked by CL)
                  address = malloc(v)
                  database[field] = address
          else
              symbol = create a new unique symbool
              address = malloc(v)
              database[symbol] = address
      address-step-settings = malloc(step-fields-symbols)
      step-name = step-settings["name"]
      step-symbol = get-new-symbol
      database[step-symbol] = address-step-settings
      parsed-steps.append((step-symbol, step-name))

for step-pair in all-steps:
    (* this is generated from LISP *)
    kimia_run(step-pair[0], step-pair[1])
   #+end_src

and every function to turn a =cl_object= into a proper object
should look like this

#+begin_src c++ :eval no
size_t
cl_object_to_<name_of_type>
 (cl_object o, std::vector<size_t> args) {
  ...
}
#+end_src

For instance for an integer this would be the function

#+begin_src c++ :eval no
size_t
cl_object_to_int (cl_object o, std::vector<size_t> args) {
  return new int(ecl_to_fixnum(o));
}
#+end_src

#+begin_src lisp :noweb-ref kimia.codegen
(defun struct-get-fields (s)
  (car s))
#+end_src

#+RESULTS:
: STRUCT-GET-FIELDS



**** Getting runners

 #+headers: :includes '(<string> <iostream> <functional> <map> <memory> <vector>)
 #+headers: :tangle test.cxx
 #+begin_src cpp :eval yes  :main no :cmdline --pedantic -Wall
using namespace std;

using FUN_TYPE = void (*)(size_t);
using SETTING_TYPE = size_t;

map<string, FUN_TYPE> DBF;
map<string, SETTING_TYPE> DBS;

struct TensorReader {string name; int age;};
void runTensorReader(TensorReader &s) {
  cout << "RUNNING TENSOR READER" << endl;
  cout << s.name << endl;
  cout << s.age << endl;
}

struct CCSD {string amplitudes; int level;};
void runCCSD(CCSD &s) {
  cout << "RUNNING CCSD" << endl;
  cout << s.amplitudes << endl;
  cout << s.level << endl;
}

void kimia_run(string sid, string algoid) {
  const auto settings(DBS[sid]);
  const auto runner(DBF[algoid]);
  runner(settings);
}

struct A {
  double *a;
  int *b;
};

int main () {

  TensorReader tr{"input.dat", 5};
  CCSD ccsd{"Singles and doulbes", 2};
  double *a = new double(5.5657e-8);
  int *b = new int(42);

  std::vector<size_t> input;
  input.push_back((size_t)a);
  input.push_back((size_t)b);

  A *as((A*)input.data());

  std::cout << *as->a << std::endl;
  std::cout << *as->b << std::endl;

  // char* bc(reinterpret_cast<char*>(&a));
  // std::cout << input.size() << std::endl;
  // for (int i(0); i<8; i++) input.push_back(bc[i]);
  // //input.insert(input.begin(), bc, bc + sizeof(double));
  // std::cout << (input.begin() == input.end()) << std::endl;

  DBS["tensor-reader-1"] = (SETTING_TYPE)&tr;
  DBF["tensor-reader"] = (FUN_TYPE)&runTensorReader;

  DBS["ccsd-1"] = (SETTING_TYPE)&ccsd;
  DBF["ccsd"] = (FUN_TYPE)&runCCSD;

  kimia_run("tensor-reader-1", "tensor-reader");
  kimia_run("ccsd-1", "ccsd");

  return 0;
}
 #+end_src

 #+RESULTS:
 | 5.5657e-08 |        |         |
 |         42 |        |         |
 |    RUNNING | TENSOR | READER  |
 |  input.dat |        |         |
 |          5 |        |         |
 |    RUNNING | CCSD   |         |
 |    Singles | and    | doulbes |
 |          2 |        |         |
 
** Testing
Let us define a poor man's test unit framework
#+begin_src lisp :tangle src/clkimia/test-data.lisp :eval no :noweb no-export
(in-package :kimia)
<<test-data-kimia>>
#+end_src

#+begin_src lisp :tangle src/clkimia/t.lisp :noweb-ref test-framework :results none

(defmacro assert-not (thing)
  `(let ((value (not ,thing)))
     (unless value
       (princ ',thing)
       (error "Assertion-not error"))))

(defmacro assert-equal (one two)
  `(let ((value (equal ,one ,two)))
     (unless value
       (format t "~2%~s~%~Tis not equal to ~%~T~s~2%"
               ',one ',two)
       (assert nil))))

(defmacro assert-eq (one two)
  `(let ((value (eq ,one ,two)))
     (unless value
       (format t "~2%~s~%~Tis not eq to ~%~T~s~2%"
               ',one ',two)
       (assert nil))))
#+end_src

and the main testing package is therefore

#+begin_src lisp :tangle src/clkimia/t.lisp :eval no :noweb no-export
(in-package :kimia)
(load "test-data.lisp")

<<test-framework>>
<<test-kimia>>
;; <<test-kimia.types>>

#+end_src

** The code
 #+begin_src lisp :noweb no-export :tangle src/clkimia/kimia.lisp
(defpackage :kimia
  (:use :cl)
  (:nicknames :k))
(in-package :kimia)

<<kimia.codegen>>
;;<<kimia.types>>
<<kimia>>

 #+end_src

 #+RESULTS:
 : COMMON-LISP-USER::WRAP-INPUT-SCRIPT

** Limitations
- Cannot create `(vec (const A))` like `std::vector<const int>` etc.
* TODO The step
** The Step
*** General idea for defining steps
  To set things in perspective, we would like to define a
  =TensorReader.lisp= file alongside =TensorReader.h= and
  =TensorReader.cxx=
  with the specification of this step, it should look something like this

  #+begin_src lisp :eval no :noweb-ref defstep-tensor-reader-example
(defstep tensor-reader
  :in
  (:name :file
   :type string
   :default "input.dat"
   :required t
   :doc "The file where the tensor is located")
  (:name :mode
   :type (member :binary :text)
   :default :binary
   :required t
   :doc "The encoding and format that the tensor is written in")
  :out
  (:name :tensor
   :type string
   :default "out.tensor"
   :required t
   :doc "The file where the tensor is located"))

  #+end_src

  and every item in the =:in= or =:out= fields
  is therefore a =step-setting-spec=.

*** Setting spec
We would like to define exactly what a setting specification (setting spec)
is. As we have seen in the example for the tensor-reader, it should be

#+begin_src lisp :eval no
(:name :file
 :type (or string null)
 :default nil
 :required t
 :doc "The file where the tensor is located")
#+end_src

We define the type =step-setting-spec= to check for the existence of the
fields and also to check that the =:default= value if of type =:type=.

  #+begin_src lisp :noweb-ref kimia.types
(defparameter *setting-spec-default* nil)
(eval-when (:compile-toplevel)
  (defun step-setting-spec-p (thing)
    (let ((ty (getf thing :type))
          (default (getf thing :default))
          (doc (getf thing :doc))
          (name (getf thing :name)))
      (check-type name keyword)
      (check-type doc string)
      (setq *setting-spec-default* default)
      ;; TODO: do this without setq
      (eval `(check-type *setting-spec-default* ,ty))
      (and name
           ty
           (member :default thing)
           (member :required thing)))))

(deftype step-setting-spec ()
  '(satisfies step-setting-spec-p))
  #+end_src

  #+RESULTS:
  : STEP-SETTING-SPEC

**** Test
We can quickly check that this code makes what we think

#+begin_src lisp :noweb-ref test-kimia.types
(let (step)
  (setq step
        '(:name :mode
          :type (member :binary :text)
          :default :binary
          :required t
          :doc "The file where the tensor is located"))
  (check-type step step-setting-spec))
#+end_src

#+RESULTS:
: NIL


*** Defining steps

 A step spec has the following syntax, as we have already
 seen

 #+begin_src lisp :eval no
(defstep
  :name name-of-the-step
  :in setting-spec*
  :out setting-spec*)
 #+end_src

For ease of writing these definitions we do not wish
to have proper lists as the value of the =:in= keyword,
so we need a function parsing exactly the =:in= part
and the =:out= part from a list

 #+begin_src lisp :noweb-ref kimia.types
(eval-when (:compile-toplevel :load-toplevel)
  (defun consume-in-out (lst &optional (tail '()))
    (let ((first (car lst))
          (rest (cdr lst)))
      (cond
        ((eq first :out) `(,(reverse tail) ,rest))
        ((eq first :in) (consume-in-out rest tail))
        ((eq lst '()) `(,(reverse tail) ,rest))
        (t (consume-in-out rest (cons first tail)))))))



#+end_src

#+RESULTS:
: GET-KEYS

We still need the definition of a step.

#+begin_src lisp :noweb-ref kimia.types
(defun step-setting-typep (setting-pair setting-spec-list)
  (let* ((key (car setting-pair))
         (value (getf setting-pair key))
         (spec (car (remove-if-not (lambda (s)
                                     (eq key (getf s :name)))
                                   setting-spec-list))))
    (typep value (getf spec :type))))

(defun step-setting-step-to-struct-spec (step-name args)
  " Input is
    'Tensor-Reader (:in setting-spec* :out setting-spec*)
  "
  (let* ((inout (consume-in-out args))
         (in-struct `(struct nil ,(mapcar
                                   (lambda (kp)
                                     `(,(getf kp :name)
                                       ,(getf kp :type)))
                                   (car inout))))
         (out-struct `(struct nil ,(mapcar
                                   (lambda (kp)
                                     `(,(getf kp :name)
                                       ,(getf kp :type)))
                                   (cadr inout)))))
    `(struct ,step-name ((:in ,in-struct)
                         (:out ,out-struct)))))

(defun step-defequiv-c++ (step-name args)
  (let ((step-struct (step-setting-step-to-struct-spec step-name args)))
    (eval `(defequiv :c++ ,step-name
      :translate (lambda (ty) (translate :c++ ,step-struct))
      :declare-var (lambda (ty vn) (declare-var :c++ ,step-struct vn))
      :define (lambda (ty) (define :c++ ,step-struct))))))

(defparameter *KIMIA-TYPES* '())
(defmacro defstep (name &rest args)
  ;; checking that name and args are of correct types
  (check-type name (and symbol (not keyword)))
  (let ((inout (consume-in-out args)))
    (dolist (in-or-out inout)
      (dolist (setting in-or-out)
        (check-type setting step-setting-spec))))
  (let* ((type-predicate-name (intern (format nil "~@:(~a~)-P" name)))
         (type-name (intern (format nil "~@:(~a~)" name)))
         (spec-fun-name (intern (format nil "~@:(~a~)-SPEC" name)))
         (default-type-fn (intern (format nil "~@:(~a~)-DEFAULT" name)))
         (inout (consume-in-out args))
         (in (car inout))
         (out (cadr inout)))
    `(progn
       (step-defequiv-c++ ',name ',args)
       (defun ,default-type-fn ()
         '(:name ,name
           :in ,(reduce (lambda (x y) (concatenate 'list x y))
                 (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                  in))
           :out ,(reduce (lambda (x y) (concatenate 'list x y))
                  (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                   out))))
       (defun ,spec-fun-name ()
         '(:name ,name :in ,in :out ,out))
       (defun ,type-predicate-name (thing)
         (check-type thing cons)
         (let* ((-name (getf thing :name))
                (-in (getf thing :in))
                (-in-keys (get-keys -in))
                (-out (getf thing :out))
                (-out-keys (get-keys -out))
                (spec (,spec-fun-name))
                (spec-name (getf spec :name))
                (spec-in (getf spec :in))
                (spec-out (getf spec :out)))
           (and (eq -name spec-name)
                (every (lambda (key)
                         (let* ((value (getf -in key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-in)))
                       -in-keys)
                (every (lambda (key)
                         (let* ((value (getf -out key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-out)))
                       -out-keys))))
       (push ',type-name *KIMIA-TYPES*)
       (deftype ,type-name ()
         '(satisfies ,type-predicate-name)))))
 #+end_src

 #+RESULTS:
 : DEFSTEP

 For instance we can use this macro in the followig manner

 #+begin_src lisp :noweb yes :noweb-ref test-kimia.types :eval no
<<defstep-tensor-reader-example>>

(check-type (tensor-reader-default)
            tensor-reader)
 #+end_src

 #+RESULTS:
 : NIL

 and we can make sure that it woks for example as

 #+begin_src lisp :results none :noweb-ref test-kimia.types :eval no
(let (step default)
  (setq step
        '(:name Tensor-Reader
          :in (:file "asdf"
               :mode :binary)
          :out (:tensor "Integral")))
  (setq default
        (tensor-reader-default))

  (check-type default tensor-reader)
  (check-type step tensor-reader))
 #+end_src

A very simple macro to check the type of a step is defined below

 #+begin_src lisp :results none :noweb-ref kimia.types
(defmacro check-step-type (step)
  (let ((name (getf step :name)))
    `(let ((step ',step))
       (check-type step ,name))))
#+end_src

which we can use like
#+begin_src lisp :noweb-ref test-kimia.types :eval no
(let ((step (tensor-reader-default)))
  (eval `(check-step-type ,step)))
#+end_src

#+RESULTS:
: NIL

*** Making steps

And we just need to create a function to easier create
steps

#+begin_src lisp :results none :noweb-ref kimia.types
(defmacro mk-stepq (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (step `(:name ,name
                 :in ,in
                 :out ,out)))
    `(progn
       (check-step-type ,step)
       ',step
       )))

(defun mk-step (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (type)
         (step)
         )
    (setq type name)
    (setq step `(:name ,name
                 :in ,in
                 :out ,out))
    (eval `(check-step-type ,step))
    step))
 #+end_src

 and we can create a step in the following manner

 #+begin_src lisp :results none :noweb-ref test-kimia.types :eval no
(mk-step
 'Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")

(mk-stepq
 Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")
 #+end_src
