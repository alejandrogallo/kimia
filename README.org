#+title: Kimia
* =CL-KIMIA=
** Introduction
What should be a good input language for a program?
A case can be made to choose lisp as an input language,
and specially Common Lisp as its dialect.

The fact that =ECL= can be easily embedded in a C or C++
program makes it quite attractive for code where quantum chemical
methods are dealt with or even machine learning codes, where
the abstraction for defining networks could very well be dealt with
through powerful lisp macros.

This document represents an investigation in this direction,
and it is written as a literate program, in the hopes that
it can be embedded in the documentation of an existing program
using =CL-KIMIA= as a powerful input user interface (IUI).

** Wrapping input

In principle we want the current user to use the input language as a
purely recipee based language, like a DSL, so we will wrap the users'
input in a monadic-like interface, where the step will return the
variable ~*KIMIA-STEPS*~ where the steps of the input are stored in
order.

#+begin_src lisp :noweb-ref kimia
(defparameter *KIMIA-STEPS* '())

(defmacro wrap-input-script (&rest arg)
  `(handler-bind
       ((error #'invoke-debugger))
     (in-package :kimia)
     (progn
       (format t "~%LISP::START evaluating KIMIA script~%")
       ,@arg
       (format t "~%LISP::DONE evaluating KIMIA~%")
       kimia::*KIMIA-STEPS*)))

(defmacro >> (&rest args)
  `(push (mk-stepq ,@args) *KIMIA-STEPS*))
#+end_src

#+RESULTS:
: WRAP-INPUT-SCRIPT
 
** The Step
*** General idea for defining steps
  To set things in perspective, we would like to define a
  =TensorReader.lisp= file alongside =TensorReader.h= and
  =TensorReader.cxx=
  with the specification of this step, it should look something like this

  #+begin_src lisp :eval no :noweb-ref defstep-tensor-reader-example
(defstep tensor-reader
  :in
  (:name :file
   :type string
   :default "input.dat"
   :required t
   :doc "The file where the tensor is located")
  (:name :mode
   :type (member :binary :text)
   :default :binary
   :required t
   :doc "The encoding and format that the tensor is written in")
  :out
  (:name :tensor
   :type string
   :default "out.tensor"
   :required t
   :doc "The file where the tensor is located"))

  #+end_src

  and every item in the =:in= or =:out= fields
  is therefore a =step-setting-spec=.

*** Setting spec
We would like to define exactly what a setting specification (setting spec)
is. As we have seen in the example for the tensor-reader, it should be

#+begin_src lisp :eval no
(:name :file
 :type (or string null)
 :default nil
 :required t
 :doc "The file where the tensor is located")
#+end_src

We define the type =step-setting-spec= to check for the existence of the
fields and also to check that the =:default= value if of type =:type=.

  #+begin_src lisp :noweb-ref kimia.types
(defparameter *setting-spec-default* nil)
(eval-when (:compile-toplevel)
  (defun step-setting-spec-p (thing)
    (let ((ty (getf thing :type))
          (default (getf thing :default))
          (doc (getf thing :doc))
          (name (getf thing :name)))
      (check-type name keyword)
      (check-type doc string)
      (setq *setting-spec-default* default)
      ;; TODO: do this without setq
      (eval `(check-type *setting-spec-default* ,ty))
      (and name
           ty
           (member :default thing)
           (member :required thing)))))

(deftype step-setting-spec ()
  '(satisfies step-setting-spec-p))
  #+end_src

  #+RESULTS:
  : STEP-SETTING-SPEC

**** Test
We can quickly check that this code makes what we think

#+begin_src lisp :noweb-ref test-kimia.types
(let (step)
  (setq step
        '(:name :mode
          :type (member :binary :text)
          :default :binary
          :required t
          :doc "The file where the tensor is located"))
  (check-type step step-setting-spec))
#+end_src

#+RESULTS:
: NIL


*** Defining steps

 A step spec has the following syntax, as we have already
 seen

 #+begin_src lisp :eval no
(defstep
  :name name-of-the-step
  :in setting-spec*
  :out setting-spec*)
 #+end_src

For ease of writing these definitions we do not wish
to have proper lists as the value of the =:in= keyword,
so we need a function parsing exactly the =:in= part
and the =:out= part from a list

 #+begin_src lisp :noweb-ref kimia.types
(eval-when (:compile-toplevel :load-toplevel)
  (defun consume-in-out (lst &optional (tail '()))
    (let ((first (car lst))
          (rest (cdr lst)))
      (cond
        ((eq first :out) `(,(reverse tail) ,rest))
        ((eq first :in) (consume-in-out rest tail))
        ((eq lst '()) `(,(reverse tail) ,rest))
        (t (consume-in-out rest (cons first tail)))))))

(defun get-keys (lst &optional (rest '()))
  "This function just gets every other element
  "
  (check-type lst (or cons null))
  (let ((head (car lst))
        (tail (cdr lst)))
    (case tail
      ((nil) (reverse rest))
      (otherwise (get-keys (cdr tail)
                           (cons head rest))))))

#+end_src

#+RESULTS:
: GET-KEYS

We still need the definition of a step.

#+begin_src lisp :noweb-ref kimia.types
(defun step-setting-typep (setting-pair setting-spec-list)
  (let* ((key (car setting-pair))
         (value (getf setting-pair key))
         (spec (car (remove-if-not (lambda (s)
                                     (eq key (getf s :name)))
                                   setting-spec-list))))
    (typep value (getf spec :type))))

(defun step-setting-step-to-struct-spec (step-name args)
  " Input is
    'Tensor-Reader (:in setting-spec* :out setting-spec*)
  "
  (let* ((inout (consume-in-out args))
         (in-struct `(struct nil ,(mapcar
                                   (lambda (kp)
                                     `(,(getf kp :name)
                                       ,(getf kp :type)))
                                   (car inout))))
         (out-struct `(struct nil ,(mapcar
                                   (lambda (kp)
                                     `(,(getf kp :name)
                                       ,(getf kp :type)))
                                   (cadr inout)))))
    `(struct ,step-name ((:in ,in-struct)
                         (:out ,out-struct)))))

(defun step-deftype-c++ (step-name args)
  (let ((step-struct (step-setting-step-to-struct-spec step-name args)))
    (eval `(deftype-c++ ,step-name
      :translate (lambda (ty) (translate-c++ ,step-struct))
      :declare-var (lambda (ty vn) (declare-var-c++ ,step-struct vn))
      :define (lambda (ty) (define-c++ ,step-struct))))))

(defparameter *KIMIA-TYPES* '())
(defmacro defstep (name &rest args)
  ;; checking that name and args are of correct types
  (check-type name (and symbol (not keyword)))
  (let ((inout (consume-in-out args)))
    (dolist (in-or-out inout)
      (dolist (setting in-or-out)
        (check-type setting step-setting-spec))))
  (let* ((type-predicate-name (intern (format nil "~@:(~a~)-P" name)))
         (type-name (intern (format nil "~@:(~a~)" name)))
         (spec-fun-name (intern (format nil "~@:(~a~)-SPEC" name)))
         (default-type-fn (intern (format nil "~@:(~a~)-DEFAULT" name)))
         (inout (consume-in-out args))
         (in (car inout))
         (out (cadr inout)))
    `(progn
       (step-deftype-c++ ',name ',args)
       (defun ,default-type-fn ()
         '(:name ,name
           :in ,(reduce (lambda (x y) (concatenate 'list x y))
                 (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                  in))
           :out ,(reduce (lambda (x y) (concatenate 'list x y))
                  (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                   out))))
       (defun ,spec-fun-name ()
         '(:name ,name :in ,in :out ,out))
       (defun ,type-predicate-name (thing)
         (check-type thing cons)
         (let* ((-name (getf thing :name))
                (-in (getf thing :in))
                (-in-keys (get-keys -in))
                (-out (getf thing :out))
                (-out-keys (get-keys -out))
                (spec (,spec-fun-name))
                (spec-name (getf spec :name))
                (spec-in (getf spec :in))
                (spec-out (getf spec :out)))
           (and (eq -name spec-name)
                (every (lambda (key)
                         (let* ((value (getf -in key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-in)))
                       -in-keys)
                (every (lambda (key)
                         (let* ((value (getf -out key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-out)))
                       -out-keys))))
       (push ',type-name *KIMIA-TYPES*)
       (deftype ,type-name ()
         '(satisfies ,type-predicate-name)))))
 #+end_src

 #+RESULTS:
 : DEFSTEP

 For instance we can use this macro in the followig manner

 #+begin_src lisp :noweb yes :noweb-ref test-kimia.types :eval no
<<defstep-tensor-reader-example>>

(check-type (tensor-reader-default)
            tensor-reader)
 #+end_src

 #+RESULTS:
 : NIL

 and we can make sure that it woks for example as

 #+begin_src lisp :results none :noweb-ref test-kimia.types :eval no
(let (step default)
  (setq step
        '(:name Tensor-Reader
          :in (:file "asdf"
               :mode :binary)
          :out (:tensor "Integral")))
  (setq default
        (tensor-reader-default))

  (check-type default tensor-reader)
  (check-type step tensor-reader))
 #+end_src

A very simple macro to check the type of a step is defined below

 #+begin_src lisp :results none :noweb-ref kimia.types
(defmacro check-step-type (step)
  (let ((name (getf step :name)))
    `(let ((step ',step))
       (check-type step ,name))))
#+end_src

which we can use like
#+begin_src lisp :noweb-ref test-kimia.types :eval no
(let ((step (tensor-reader-default)))
  (eval `(check-step-type ,step)))
#+end_src

#+RESULTS:
: NIL

*** Making steps

And we just need to create a function to easier create
steps

#+begin_src lisp :results none :noweb-ref kimia.types
(defmacro mk-stepq (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (step `(:name ,name
                 :in ,in
                 :out ,out)))
    `(progn
       (check-step-type ,step)
       ',step
       )))

(defun mk-step (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (type)
         (step)
         )
    (setq type name)
    (setq step `(:name ,name
                 :in ,in
                 :out ,out))
    (eval `(check-step-type ,step))
    step))
 #+end_src

 and we can create a step in the following manner

 #+begin_src lisp :results none :noweb-ref test-kimia.types :eval no
(mk-step
 'Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")

(mk-stepq
 Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")
 #+end_src

** Host code generation
*** Introduction

 From a spec, we would like to be able to create autoamtically a
 =struct= that mirror the spec in order to be passed to other functions
 in c++.

 For instance, in the case of the tensor reader, we would
 like to create the following

 #+begin_src cpp :eval yes :includes '(<string> <iostream>)
struct TensorReaderSettings {
  struct In {
    enum Mode {binary, text};
    std::string *file;
    Mode *mode;
    In() {
      mode = new Mode(binary);
      file = nullptr;
    }
  } in;
  struct Out {
    std::string *tensor;
    Out() {
      tensor = new std::string("file.out");
    }
  } out;
};
auto p = TensorReaderSettings::In::Mode::text;
std::cout << p << std::endl;
TensorReaderSettings s;
std::cout << *s.out.tensor << std::endl;
 #+end_src

 #+RESULTS:
 |        1 |
 | file.out |

 together with a converter function from a =cl_object= into
 a =TensorReaderSettings=

 #+begin_src cpp :eval no
TensorReaderSettings
cl_object_to_TensorReaderSettings (cl_object *o) {
}
 #+end_src

 And for these structs we need a functions that from a common lisp
 type constructs a declaration inside the struct or somewhere else.

 First of all we have to make a choice in order to have a simpler
 more maintainable system.
 We will translate every CL type into a poiter of a related type
 in C++, which means that in principle every type can also be =NULL=,
 or =nullptr= in C++.

 There is also the problem of having variables, we should allow
 for symbols to also be passed to any CL variable, they will act as
 named pointers, so that one step can access and modify global data
 that later on other steps can retrieve or further modify.


*** List of types

 | Built-in CL type | C++ interpretation |
 |------------------+--------------------|
 | =string=         | =std::string=      |
 | =(member :a :b)= | =enum {a, b}=      |
 | =integer=        | =int=              |
 | =double-float=   | =double=           |
 | =single-float=   | =float=            |
 | =(list F N)=     | =std::array<F, N>= |
 | =(list F)=       | =std::vector<F>=   |
 | =(vector F N)=   | =std::array<F, N>= |
 | =(vector F)=     | =std::vector<F>=   |
 | =(complex F)=    | =std::complex<F>=  |

 | Kimia CL type                        | C++ intepretation               |
 |--------------------------------------+---------------------------------|
 | =(or symbol null)= through =(-> a)=  | =a*=                            |
 | =(struct [name] ((:name int) ... ))= | =struct [Name] {int name; ...}= |
 | =(enum [name] :a :b ))=              | =enum [Name] { A, B, }=         |

- [X] vector
- [X] symbol
- [X] string
- [X] single-float
- [X] keyword
- [X] int
- [X] double-float
- [ ] list
- [ ] hashtable
- [ ] complex



*** General structure of a type
With this information as motivation we can see in general what we have to do
to use a type from common lisp in the host language.
- Define type (if it is a built-in there is no need).
- Define a constructor.
- Define a declaration.

The C++ programmer may be wondering why we are not considering generic
programming through the templating metaprogramming infrastructure.

The main reason is that creating generic steps would be an added complication
that does not really add much value from the c++ side. Let us suppose
we have a step that might have as a setting a =double= or an =int=
in a polymorphic way.

It is still possible to write our generic function and then define
accordin function pointers or =std::function= to the said functions.

#+begin_src cpp :eval yes :includes '(<string> <iostream> <functional>) :main no :results raw

using StepOneSetting_double = double;
using StepOneSetting_int = int;

template <typename S>
void runStepOne(S s) { std::cout << s << std::endl; }

std::function<void(StepOneSetting_double)>
 runStepOne_double = runStepOne<double>;
std::function<void(StepOneSetting_int)>
 runStepOne_int = runStepOne<StepOneSetting_int>;

struct Connection {
  enum {IN, OUT} in;
  enum {Five, Six} out;
};

int main () {
  Connection c;
  c.in = Connection::IN;
  c.out = Connection::Five;
  runStepOne_double(42.001);
  runStepOne_int(42);
  return 0;
}
#+end_src


*** Type definitions idea

  Some types are high-kinded, in C++ parlance this is akin to
  having template arguments.
  Some types are already defined and some others must be defined.

- define (type type-name) :: define for the first time.
  - For built-ins in c and c++ this is just empty
  - For structs and enums, if no type-name is given it should be defined in place,
    which is useful for declaring variables.
- declare-var (type type-name var-name) :: declare a variable
  - For built-ins in c and c++ this is just =<type> <var-name>=
  - For structs and enums if no type-name is given then we define the type in place
    If a =type-name= is given then the sentence should be =<type-name> <var-name>=.

- give translation (this also for nameless structs/enums/unions gives the whole struct)
- give variable declaration (which works well for translation)
- give definition which should fail in the case of nameless things, or just give emtpy.
  and give emtpy also for builtins.

#+begin_src lisp :eval no
(deftype-c++ (array F N)
  :translate "int"
  :declare-var (lambda (type type-name var-name)
             (format nil "~a ~a;"
                     (int-c++-translate int)
                     (string var-name)
                     ))
  :define ""
  :generic (F N))
#+end_src

*** Define c++ types

Naming conventions in C++

#+begin_src lisp :noweb-ref kimia.codegen
(defun endl () (format nil "~%"))

(defun c++-type-name (thing)
  (remove-if (lambda (x) (string= x "-"))
             (string-capitalize
              (string-downcase thing))))

(defun c++-var-name (thing)
  (nstring-downcase
   (remove-if (lambda (x) (string= x "-"))
              (string-capitalize
               (string-downcase thing)))
   :start 0
   :end 1))

#+end_src

#+RESULTS:
: C++-VAR-NAME

and something a little bit more challenging

#+begin_src lisp :noweb-ref kimia.codegen
(defparameter *KIMIA-TYPES* '())

(defmacro c++-declare-var-fn-default (translate)
  `(lambda (ty vn)
     (format nil "~a ~a;"
             (funcall ,translate ty)
             (c++-var-name vn))))


(defmacro deftype-c++ (type &key
                              translate
                              (declare-var nil)
                              (define nil)
                              (satisfies nil)
                              (generic nil))
  (let* ((type-name (etypecase type
                      (cons (car type))
                      (symbol type)))
         (type-c++-name (intern (format nil "~A-C++" type-name)))
         (fun-or-scalar (lambda (thing)
                          (etypecase thing
                            (cons (eval thing))
                            (compiled-function thing)
                            ((or null string) (eval `(lambda (&optional args)
                                                       ,thing))))))
         (translate (funcall fun-or-scalar translate))
         (declare-var (or declare-var
                          (c++-declare-var-fn-default translate))))
    `(progn
       (defparameter ,type-c++-name nil)
       (setq ,type-c++-name
             '(:translate ,translate
               :declare-var ,(funcall fun-or-scalar declare-var)
               :define ,(funcall fun-or-scalar define))))
    ))

(defmacro translate-c++ (ty)
  (let* ((ty-name (etypecase ty
                    (cons (car ty))
                    (symbol ty)))
         (ty-c++ (intern (format nil "~a-C++" ty-name))))
    `(funcall (getf ,ty-c++ :translate) ',ty)))

(defmacro define-c++ (ty)
  (let* ((ty-name (etypecase ty
                    (cons (car ty))
                    (symbol ty)))
         (ty-c++ (intern (format nil "~a-C++" ty-name))))
    `(funcall (getf ,ty-c++ :define) ',ty)))

(defmacro declare-var-c++ (ty vn)
  (let* ((ty-name (etypecase ty
                    (cons (car ty))
                    (symbol ty)))
         (ty-c++ (intern (format nil "~a-C++" ty-name))))
    `(funcall (getf ,ty-c++ :declare-var) ',ty ',vn)))
#+end_src

#+RESULTS:
: DECLARE-VAR-C++

*** Definition for simple C++ types

#+begin_src lisp :noweb-ref kimia.codegen
(deftype-c++ integer :translate "int")
(deftype-c++ double :translate "double")
(deftype-c++ string :translate "std::string")
(deftype-c++ double-float :translate "double")
(deftype-c++ single-float :translate "float")
(deftype-c++ float :translate "float")
(deftype-c++ boolean :translate "bool")

(deftype-c++ (vector F)
  :translate (lambda (ty)
               (format nil "std::vector< ~a >"
                       (eval `(translate-c++ ,(cadr ty))))))

(deftype-c++ (array F N)
  :translate (lambda (ty)
               (format nil "std::array< ~a, ~a >"
                       (eval `(translate-c++ ,(cadr ty)))
                       (caddr ty))))
#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x21e9280> :DECLARE-VAR
:  #<bytecompiled-closure #<bytecompiled-function 0x30d2640>> :DEFINE
:  #<bytecompiled-function 0x21e9230>)

*** The struct

#+begin_src lisp :noweb-ref kimia.codegen
(defun translate-struct-c++ (ty)
  (let* ((ty-name (cadr ty))
         (name (if ty-name (c++-type-name ty-name) ""))
         (fields (caddr ty)))
    (concatenate 'string
                 "struct " (or name "")
                 " {" (endl)
                 (eval
                  `(concatenate 'string
                                ,@(loop for kp in fields
                                        collect
                                        (format nil
                                                "  ~a~a"
                                                (eval
                                                 `(declare-var-c++
                                                   ,(cadr kp)
                                                   ,(car kp)))
                                                (endl)))))
                 "}")))

(defun declare-var-struct-c++ (ty vn)
  (let* ((name (cadr ty))
         (pre-var (etypecase name
                    (null (translate-struct-c++ ty))
                    (t (c++-type-name name)))))
    (format nil "~a ~a;"
            pre-var
            (c++-var-name vn))))

(defun define-struct-c++ (ty)
  (format nil "~a;" (translate-struct-c++ ty)))

(deftype-c++ (struct name args)
  :translate (lambda (ty) (translate-struct-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-struct-c++ ty vn))
  :define (lambda (ty) (define-struct-c++ ty)))

#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x3067910> :DECLARE-VAR
:  #<bytecompiled-function 0x30677d0> :DEFINE #<bytecompiled-function 0x3067780>)

*** The enums
    
#+begin_src lisp :noweb-ref kimia.codegen
(defun translate-enum-c++ (ty)
  (let* ((ty-name (cadr ty))
         (name (if ty-name (c++-type-name ty-name) ""))
         (fields (cddr ty)))
    (concatenate 'string
                 "enum "
                 (or name "")
                 " {"
                 (endl)
                 (eval
                  `(concatenate 'string
                                ,@(loop for kp in fields
                                        collect
                                        (format nil
                                                "  ~a,~a"
                                                kp
                                                (endl)))))
                 "}")))

(defun declare-var-enum-c++ (ty vn)
  (let* ((name (cadr ty))
         (fields (caddr ty))
         (pre-var (etypecase name
                    (null (translate-enum-c++ ty))
                    (t (string-capitalize name)))))
    (format nil "~a ~a;" pre-var (c++-var-name vn))))

(defun define-enum-c++ (ty)
  (format nil "~a;" (translate-enum-c++ ty)))

(deftype-c++ (enum name args)
  :translate (lambda (ty) (translate-enum-c++ ty))
  :declare-var (lambda (ty vn) (declare-var-enum-c++ ty vn))
  :define (lambda (ty) (define-enum-c++ ty)))

(deftype-c++ (member args)
  :translate (lambda (ty)
               (translate-enum-c++ `(enum nil ,@(cdr ty))))
  :declare-var (lambda (ty vn)
                 (declare-var-enum-c++ `(enum nil ,@(cdr ty)) vn))
  :define (lambda (ty)
            (define-enum-c++ `(enum nil ,@(cdr ty)))))
#+end_src

#+RESULTS:
: (:TRANSLATE #<bytecompiled-function 0x30671e0> :DECLARE-VAR
:  #<bytecompiled-function 0x3067190> :DEFINE #<bytecompiled-function 0x26eb9b0>)



** Testing
#+begin_src lisp :tangle src/clkimia/t.lisp :eval no :noweb no-export
(in-package :kimia)

<<test-kimia.types>>

#+end_src

** The code
 #+begin_src lisp :noweb no-export :tangle src/clkimia/kimia.lisp
(defpackage :kimia
  (:use :cl)
  (:nicknames :k))
(in-package :kimia)

<<kimia.codegen>>
<<kimia.types>>
<<kimia>>

 #+end_src

 #+RESULTS:
 : COMMON-LISP-USER::WRAP-INPUT-SCRIPT
