#+title: Kimia
* =ECL= input language and C++

What should be the input language of a good program?
Here we will write some notes about this topic.

In principle it is enough to have the same or similar syntax
as in the old one

* Testing
#+begin_src lisp :tangle src/clkimia/t.lisp :eval no
(require 'ecl-quicklisp)
(ecl-quicklisp::install-quicklisp "/tmp/")
(ql:quickload :fiasco)
#+end_src

* The Step
** General definition
 To set things in perspective, we would like to define a
 =TensorReader.lisp= file alongside =TensorReader.h= and
 =TensorReader.cxx=
 with the specification of this step, it should look something like this

 #+begin_src lisp :eval no
(defstep Tensor-Reader
  :in
    (:name file
     :type (or string null)
     :default nil
     :required t
     :doc "The file where the tensor is located")
    (:name mask
     :type (or null (tensor double))
     :required nil
     :doc "A mask tensor")
  :out
    (:name dimension
     :type (vector integer)
     :required nil
     :doc "The dimension of the read tensor"))
 #+end_src

 and every item in the =:in= or =:out= fields
 is therefore a =step-setting-spec=.

** Setting spec
 It is quite clear this type how it should be defined.

 #+begin_src lisp :noweb-ref step-setting-spec
(defun step-setting-spec-p (thing)
  (let ((ty (getf thing :type))
        (default (getf thing :default))
        (doc (getf thing :doc))
        (name (getf thing :name)))
    (check-type name keyword)
    (check-type doc string)
    (setq *setting-spec-default* default)
    ;; TODO: do this without setq
    (eval `(check-type *setting-spec-default* ,ty))
    (and name
         ty
         (member :default thing)
         (member :required thing))))

(deftype step-setting-spec ()
  '(satisfies step-setting-spec-p))
 #+end_src

 #+RESULTS:
 : STEP-SETTING-SPEC

 Here therefore we force every spec to have the form
 #+begin_src lisp :eval no
(:name :file
 :type (or string null)
 :default nil
 :required t
 :doc "The file where the tensor is located")
 #+end_src
 and most importantly the type of the =:default= value


** Step

A step spec has the following syntax, as we have already
seen

#+begin_src lisp :eval no
(defstep
  :name name-of-the-step
  :in setting-spec*
  :out setting-spec*)
#+end_src

Here we should

#+begin_src lisp
(defun consume-in-out (lst &optional (tail '()))
  (let ((first (car lst))
        (rest (cdr lst)))
    (cond
      ((eq first :out) `(,(reverse tail) ,rest))
      ((eq first :in) (consume-in-out rest tail))
      ((eq lst '()) `(,(reverse tail) ,rest))
      (t (consume-in-out rest (cons first tail))))))

(defun get-keys (lst &optional (rest '()))
  "This function just gets every other element
  "
  (check-type lst (or cons null))
  (let ((head (car lst))
        (tail (cdr lst)))
    (case tail
      ((nil) (reverse rest))
      (otherwise (get-keys (cdr tail)
                           (cons head rest))))))

(defun step-setting-typep (setting-pair setting-spec-list)
  (let* ((key (car setting-pair))
         (value (getf setting-pair key))
         (spec (car (remove-if-not (lambda (s)
                                     (eq key (getf s :name)))
                                   setting-spec-list))))
    (typep value (getf spec :type))))

(defparameter *KIMIA-TYPES* '())
(defmacro defstep (name &rest args)
  ;; checking that name and args are of correct types
  (check-type name (and symbol (not keyword)))
  (let ((inout (consume-in-out args)))
    (dolist (in-or-out inout)
      (dolist (setting in-or-out)
        (check-type setting step-setting-spec))))
  (let* ((type-predicate-name (intern (format nil "~@:(~a~)-P" name)))
         (type-name (intern (format nil "~@:(~a~)" name)))
         (spec-fun-name (intern (format nil "~@:(~a~)-SPEC" name)))
         (default-type-fn (intern (format nil "~@:(~a~)-DEFAULT" name)))
         (c++-name-fn (intern (format nil "~@:(~a~)-C++-NAME" name)))
         (inout (consume-in-out args))
         (in (car inout))
         (in-keys (mapcar (lambda (x) (getf x :name)) in))
         (out (cadr inout)))
    `(progn
       (defun ,c++-name-fn ()
         ,(remove-if (lambda (x) (string= x "-"))
                    (string-capitalize
                     (string-downcase (string name)))))
       (defun ,default-type-fn ()
         '(:name ,name
           :in ,(reduce (lambda (x y) (concatenate 'list x y))
                 (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                  in))
           :out ,(reduce (lambda (x y) (concatenate 'list x y))
                  (mapcar (lambda (s) `(,(getf s :name) ,(getf s :default)))
                   out))))
       (defun ,spec-fun-name ()
         '(:name ,name :in ,in :out ,out))
       (defun ,type-predicate-name (thing)
         (check-type thing cons)
         (let* ((-name (getf thing :name))
                (-in (getf thing :in))
                (-in-keys (get-keys -in))
                (-out (getf thing :out))
                (-out-keys (get-keys -out))
                (spec (,spec-fun-name))
                (spec-name (getf spec :name))
                (spec-in (getf spec :in))
                (spec-out (getf spec :out)))
           (and (eq -name spec-name)
                (every (lambda (key)
                         (let* ((value (getf -in key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-in)))
                       -in-keys)
                (every (lambda (key)
                         (let* ((value (getf -out key))
                                (pair `(,key ,value)))
                           (step-setting-typep pair spec-out)))
                       -out-keys))))
       (push ',type-name *KIMIA-TYPES*)
       (deftype ,type-name ()
         '(satisfies ,type-predicate-name)))))
#+end_src

#+RESULTS:
: DEFSTEP

For instance we can use this macro in the followig manner

#+begin_src lisp
(defstep
  tensor-reader
  :in
  (:name :file
   :type (or string null)
   :default nil
   :required t
   :doc "The file where the tensor is located")
  (:name :mode
   :type (member :binary :text)
   :default :binary
   :required t
   :doc "The file where the tensor is located")
  :out
  (:name :tensor
   :type string
   :default "out.tensor"
   :required t
   :doc "The file where the tensor is located"))

(tensor-reader-default)

#+end_src

#+RESULTS:
| :NAME | TENSOR-READER | :IN | (:FILE NIL :MODE :BINARY) | :OUT | (:TENSOR out.tensor) |

and we can make sure that it woks for example as

#+begin_src lisp :results none
(let (step default)
  (setq step
        '(:name Tensor-Reader
          :in (:file "asdf"
               :mode :binary)
          :out (:tensor "Integral")))
  (setq default
        (tensor-reader-default))

  (check-type default tensor-reader)
  (check-type step tensor-reader))
#+end_src

And we just need to create a function to easier create
steps

#+begin_src lisp :results none
(defmacro check-step-type (step)
  (let ((name (getf step :name)))
    `(let ((step ',step))
       (check-type step ,name))))

(defmacro mk-stepq (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (step `(:name ,name
                 :in ,in
                 :out ,out)))
    `(progn
       (check-step-type ,step)
       ',step
       )))

(defun mk-step (name &rest args)
  (check-type name symbol)
  (let* ((in-out (consume-in-out args))
         (in (car in-out))
         (out (cadr in-out))
         (type)
         (step)
         )
    (setq type name)
    (setq step `(:name ,name
                 :in ,in
                 :out ,out))
    (eval `(check-step-type ,step))
    step))
#+end_src

and we can create a step in the following manner

#+begin_src lisp :results none
(mk-step
 'Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")

(mk-stepq
 Tensor-Reader
 :in
 :file "amplitudes.dat"
 :mode :binary
 :out
 :tensor "Whatever")
#+end_src

** C++ headers from spec

From a spec, we would like to be able
to create autoamtically a =struct=
that mirror the spec in order to be passed to other
functions in c++.

For instance, in the case of the tensor reader, we would
like to create the following

#+begin_src cpp :eval yes :includes '(<string> <iostream>)
struct TensorReaderSettings {
  struct In {
    enum Mode {binary, text};
    std::string *file;
    Mode *mode;
    In() {
      mode = new Mode(binary);
      file = nullptr;
    }
  } in;
  struct Out {
    std::string *tensor;
    Out() {
      tensor = new std::string("file.out");
    }
  } out;
};
auto p = TensorReaderSettings::In::Mode::text;
std::cout << p << std::endl;
TensorReaderSettings s;
std::cout << *s.out.tensor << std::endl;
#+end_src

#+RESULTS:
|        1 |
| file.out |

together with a converter function from a =cl_object= into
a =TensorReaderSettings=

#+begin_src cpp :eval no
TensorReaderSettings
cl_object_to_TensorReaderSettings (cl_object *o) {
}
#+end_src

And for these structs we need a functions that from a common lisp
type constructs a declaration inside the struct or somewhere else.

First of all we have to make a choice in order to have a simpler
more maintainable system.
We will translate every CL type into a poiter of a related type
in C++, which means that in principle every type can also be =NULL=,
or =nullptr= in C++.

There is also the problem of having variables, we should allow
for symbols to also be passed to any CL variable, they will act as
named pointers, so that one step can access and modify global data
that later on other steps can retrieve or further modify.

| CL type          | C++ interpretation |
|------------------+--------------------|
| =string=         | =std::string*=     |
| =(member :a :b)= | =(enum {a, b})*=   |
| =integer=        | =int*=             |
| =double-float=   | =double*=          |
| =single-float=   | =float*=           |
| =(list F N)=     | =std::array<F, N>*= |
| =(list F)=       | =std::vector<F>*=  |
| =(vector F N)=   | =std::array<F, N>*= |
| =(vector F)=     | =std::vector<F>*=  |

#+begin_src lisp

(defparameter *kimia-lower-kinded-types*
  '(string
    integer
    symbol
    keyword))

(defun cl-c++-type-caller (type)
  (let ((name (ecase (type-of type)
                (symbol type)
                (cons (car type)))))
    (funcall (intern (format nil "CL-~@:(~A~)-TO-C++-TYPE" name)) type)))

(defun cl-boolean-to-c++-type      (&optional type) "bool")
(defun cl-member-to-c++-type       (&optional type) "enum")
(defun cl-int-to-c++-type          (&optional type) "int")
(defun cl-string-to-c++-type       (&optional type) "std::string")
(defun cl-double-float-to-c++-type (&optional type) "double")
(defun cl-single-float-to-c++-type (&optional type) "single")
(defun cl-vector-to-c++-type (type)
  (check-type type cons)
  (ecase (length type)
    (2 (let ((field (cadr type)))
         (format nil "std::vector<~a>" (cl-c++-type-caller field))))
    (3 "array<F, 5>")))

;; list
;; int
;; single-float
;; double-float
;; complex
;; symbol
;; keyword
;; hashtable
;; vector
;; string
;; pathname
#+end_src



#+begin_src lisp
(let ((kimia-types *KIMIA-TYPES*)
      (reader (tensor-reader-default))
      (maybe-string '(or string null))
      (s "asdf"))
  (push 'or kimia-types)
  (print kimia-types)
  (eval `(check-step-type ,reader))
  (eval
   `(etypecase ',reader
      (,maybe-string (print "std::string*"))
      (,kimia-types (print "kimia"))
      (t (print "bliad")))))
#+end_src

#+RESULTS:
: kimia
